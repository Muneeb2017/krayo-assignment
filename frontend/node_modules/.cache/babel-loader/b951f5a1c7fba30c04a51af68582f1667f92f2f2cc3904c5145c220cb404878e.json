{"ast":null,"code":"import { FocusKeys } from '@primer/behaviors';\nimport { isFocusable } from '@primer/behaviors/utils';\nimport { omit } from '@styled-system/props';\nimport React__default, { useRef, useState } from 'react';\nimport { useRefObjectAsForwardedRef } from '../hooks/useRefObjectAsForwardedRef.js';\nimport { useFocusZone } from '../hooks/useFocusZone.js';\nimport Text from '../Text.js';\nimport Token from '../Token/Token.js';\nimport TextInputInnerVisualSlot from '../_TextInputInnerVisualSlot.js';\nimport TextInputWrapper, { textInputHorizPadding } from '../_TextInputWrapper.js';\nimport UnstyledTextInput from '../_UnstyledTextInput.js';\nimport Box from '../Box/Box.js';\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  extralarge: 2,\n  xlarge: 2 // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n};\n\n// using forwardRef is important so that other components (ex. Autocomplete) can use the ref\nfunction TextInputWithTokensInnerComponent(_ref, forwardedRef) {\n  let {\n    icon: IconComponent,\n    leadingVisual: LeadingVisual,\n    trailingVisual: TrailingVisual,\n    loading,\n    loaderPosition = 'auto',\n    contrast,\n    className,\n    block,\n    disabled,\n    sx: sxProp,\n    tokens,\n    onTokenRemove,\n    tokenComponent: TokenComponent = Token,\n    preventTokenWrapping = false,\n    size = 'xlarge',\n    hideTokenRemoveButtons = false,\n    maxHeight,\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    validationStatus,\n    variant: variantProp,\n    // deprecated. use `size` instead\n    visibleTokenCount,\n    ...rest\n  } = _ref;\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useRef(null);\n  useRefObjectAsForwardedRef(forwardedRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return ref.current || undefined;\n      }\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId);\n\n    // HACK: wait a tick for the token node to be removed from the DOM\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0];\n\n      // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current;\n        // if there are no tokens left, focus the input\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n  const handleTokenFocus = tokenIndex => () => {\n    setSelectedTokenIndex(tokenIndex);\n  };\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current4;\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n  const handleInputBlur = event => {\n    onBlur && onBlur(event);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current5;\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n    const lastToken = tokens[tokens.length - 1];\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      }\n\n      // HACK: for some reason we need to wait a tick for `.select()` to work\n      setTimeout(() => {\n        var _ref$current4;\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n  const focusInput = () => {\n    var _ref$current5;\n    (_ref$current5 = ref.current) === null || _ref$current5 === void 0 ? void 0 : _ref$current5.focus();\n  };\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    extralarge: 'medium',\n    xlarge: 'medium' // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n  };\n\n  const showLeadingLoadingIndicator = loading && (loaderPosition === 'leading' || Boolean(LeadingVisual && loaderPosition !== 'trailing'));\n  const showTrailingLoadingIndicator = loading && (loaderPosition === 'trailing' || loaderPosition === 'auto' && !LeadingVisual);\n  return /*#__PURE__*/React__default.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual || showLeadingLoadingIndicator),\n    hasTrailingVisual: Boolean(TrailingVisual || showTrailingLoadingIndicator),\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React__default.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), /*#__PURE__*/React__default.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"leading\",\n    showLoadingIndicator: showLeadingLoadingIndicator\n  }, typeof LeadingVisual === 'function' ? /*#__PURE__*/React__default.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React__default.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React__default.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React__default.createElement(UnstyledTextInput, _extends({\n    ref: ref,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), visibleTokens.map((_ref2, i) => {\n    let {\n      id,\n      ...tokenRest\n    } = _ref2;\n    return /*#__PURE__*/React__default.createElement(TokenComponent, _extends({\n      key: id,\n      onFocus: handleTokenFocus(i),\n      onBlur: handleTokenBlur,\n      onKeyUp: handleTokenKeyUp,\n      onClick: preventTokenClickPropagation,\n      isSelected: selectedTokenIndex === i,\n      onRemove: () => {\n        handleTokenRemove(id);\n      },\n      hideRemoveButton: hideTokenRemoveButtons,\n      size: size,\n      tabIndex: 0\n    }, tokenRest));\n  }), tokensAreTruncated && tokens.length - visibleTokens.length ? /*#__PURE__*/React__default.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), /*#__PURE__*/React__default.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"trailing\",\n    showLoadingIndicator: showTrailingLoadingIndicator\n  }, typeof TrailingVisual === 'function' ? /*#__PURE__*/React__default.createElement(TrailingVisual, null) : TrailingVisual));\n}\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React__default.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.displayName = 'TextInputWithTokens';\nvar TextInputWithTokens$1 = TextInputWithTokens;\nexport { TextInputWithTokens$1 as default };","map":{"version":3,"names":["FocusKeys","isFocusable","omit","React__default","useRef","useState","useRefObjectAsForwardedRef","useFocusZone","Text","Token","TextInputInnerVisualSlot","TextInputWrapper","textInputHorizPadding","UnstyledTextInput","Box","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","overflowCountFontSizeMap","small","medium","large","extralarge","xlarge","TextInputWithTokensInnerComponent","_ref","forwardedRef","icon","IconComponent","leadingVisual","LeadingVisual","trailingVisual","TrailingVisual","loading","loaderPosition","contrast","className","block","disabled","sx","sxProp","tokens","onTokenRemove","tokenComponent","TokenComponent","preventTokenWrapping","size","hideTokenRemoveButtons","maxHeight","width","widthProp","minWidth","minWidthProp","maxWidth","maxWidthProp","validationStatus","variant","variantProp","visibleTokenCount","rest","onBlur","onFocus","onKeyDown","inputPropsRest","ref","selectedTokenIndex","setSelectedTokenIndex","tokensAreTruncated","setTokensAreTruncated","Boolean","containerRef","focusOutBehavior","bindKeys","ArrowHorizontal","HomeAndEnd","focusableElementFilter","element","getAttributeNames","includes","getNextFocusable","direction","_containerRef$current","undefined","nextIndex","current","children","handleTokenRemove","tokenId","setTimeout","_containerRef$current2","_containerRef$current3","nextElementToFocus","firstFocusable","Array","from","find","el","focus","_ref$current","handleTokenFocus","tokenIndex","handleTokenBlur","_containerRef$current4","contains","document","activeElement","handleTokenKeyUp","event","_ref$current2","handleInputFocus","handleInputBlur","_containerRef$current5","handleInputKeyDown","e","_ref$current3","value","lastToken","id","text","_ref$current4","select","focusInput","_ref$current5","preventTokenClickPropagation","stopPropagation","visibleTokens","slice","inputSizeMap","showLeadingLoadingIndicator","showTrailingLoadingIndicator","createElement","hasLeadingVisual","hasTrailingVisual","onClick","paddingLeft","py","display","overflow","hasLoadingIndicator","visualPosition","showLoadingIndicator","alignItems","flexWrap","marginLeft","marginBottom","flexGrow","flexShrink","order","type","height","map","_ref2","tokenRest","onKeyUp","isSelected","onRemove","hideRemoveButton","tabIndex","color","fontSize","displayName","TextInputWithTokens","forwardRef","TextInputWithTokens$1","default"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/TextInputWithTokens/TextInputWithTokens.js"],"sourcesContent":["import { FocusKeys } from '@primer/behaviors';\nimport { isFocusable } from '@primer/behaviors/utils';\nimport { omit } from '@styled-system/props';\nimport React__default, { useRef, useState } from 'react';\nimport { useRefObjectAsForwardedRef } from '../hooks/useRefObjectAsForwardedRef.js';\nimport { useFocusZone } from '../hooks/useFocusZone.js';\nimport Text from '../Text.js';\nimport Token from '../Token/Token.js';\nimport TextInputInnerVisualSlot from '../_TextInputInnerVisualSlot.js';\nimport TextInputWrapper, { textInputHorizPadding } from '../_TextInputWrapper.js';\nimport UnstyledTextInput from '../_UnstyledTextInput.js';\nimport Box from '../Box/Box.js';\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst overflowCountFontSizeMap = {\n  small: 0,\n  medium: 1,\n  large: 1,\n  extralarge: 2,\n  xlarge: 2 // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n};\n\n// using forwardRef is important so that other components (ex. Autocomplete) can use the ref\nfunction TextInputWithTokensInnerComponent({\n  icon: IconComponent,\n  leadingVisual: LeadingVisual,\n  trailingVisual: TrailingVisual,\n  loading,\n  loaderPosition = 'auto',\n  contrast,\n  className,\n  block,\n  disabled,\n  sx: sxProp,\n  tokens,\n  onTokenRemove,\n  tokenComponent: TokenComponent = Token,\n  preventTokenWrapping = false,\n  size = 'xlarge',\n  hideTokenRemoveButtons = false,\n  maxHeight,\n  width: widthProp,\n  minWidth: minWidthProp,\n  maxWidth: maxWidthProp,\n  validationStatus,\n  variant: variantProp,\n  // deprecated. use `size` instead\n  visibleTokenCount,\n  ...rest\n}, forwardedRef) {\n  const {\n    onBlur,\n    onFocus,\n    onKeyDown,\n    ...inputPropsRest\n  } = omit(rest);\n  const ref = useRef(null);\n  useRefObjectAsForwardedRef(forwardedRef, ref);\n  const [selectedTokenIndex, setSelectedTokenIndex] = useState();\n  const [tokensAreTruncated, setTokensAreTruncated] = useState(Boolean(visibleTokenCount));\n  const {\n    containerRef\n  } = useFocusZone({\n    focusOutBehavior: 'wrap',\n    bindKeys: FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd,\n    focusableElementFilter: element => {\n      return !element.getAttributeNames().includes('aria-hidden');\n    },\n    getNextFocusable: direction => {\n      var _containerRef$current;\n      if (!selectedTokenIndex && selectedTokenIndex !== 0) {\n        return undefined;\n      }\n      let nextIndex = selectedTokenIndex + 1; // \"+ 1\" accounts for the first element: the text input\n\n      if (direction === 'next') {\n        nextIndex += 1;\n      }\n      if (direction === 'previous') {\n        nextIndex -= 1;\n      }\n      if (nextIndex > tokens.length || nextIndex < 1) {\n        return ref.current || undefined;\n      }\n      return (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.children[nextIndex];\n    }\n  }, [selectedTokenIndex]);\n  const handleTokenRemove = tokenId => {\n    onTokenRemove(tokenId);\n\n    // HACK: wait a tick for the token node to be removed from the DOM\n    setTimeout(() => {\n      var _containerRef$current2, _containerRef$current3;\n      const nextElementToFocus = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.children[selectedTokenIndex || 0];\n\n      // when removing the first token by keying \"Backspace\" or \"Delete\",\n      // `nextFocusableElement` is the div that wraps the input\n      const firstFocusable = nextElementToFocus && isFocusable(nextElementToFocus) ? nextElementToFocus : Array.from(((_containerRef$current3 = containerRef.current) === null || _containerRef$current3 === void 0 ? void 0 : _containerRef$current3.children) || []).find(el => isFocusable(el));\n      if (firstFocusable) {\n        firstFocusable.focus();\n      } else {\n        var _ref$current;\n        // if there are no tokens left, focus the input\n        (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.focus();\n      }\n    }, 0);\n  };\n  const handleTokenFocus = tokenIndex => () => {\n    setSelectedTokenIndex(tokenIndex);\n  };\n  const handleTokenBlur = () => {\n    setSelectedTokenIndex(undefined);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus between tokens,\n    // but still hides the tokens when the user blurs the token by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current4;\n      if (!((_containerRef$current4 = containerRef.current) !== null && _containerRef$current4 !== void 0 && _containerRef$current4.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleTokenKeyUp = event => {\n    if (event.key === 'Escape') {\n      var _ref$current2;\n      (_ref$current2 = ref.current) === null || _ref$current2 === void 0 ? void 0 : _ref$current2.focus();\n    }\n  };\n  const handleInputFocus = event => {\n    onFocus && onFocus(event);\n    setSelectedTokenIndex(undefined);\n    visibleTokenCount && setTokensAreTruncated(false);\n  };\n  const handleInputBlur = event => {\n    onBlur && onBlur(event);\n\n    // HACK: wait a tick and check the focused element before hiding truncated tokens\n    // this prevents the tokens from hiding when the user is moving focus from the input to a token,\n    // but still hides the tokens when the user blurs the input by tabbing out or clicking somewhere else on the page\n    setTimeout(() => {\n      var _containerRef$current5;\n      if (!((_containerRef$current5 = containerRef.current) !== null && _containerRef$current5 !== void 0 && _containerRef$current5.contains(document.activeElement)) && visibleTokenCount) {\n        setTokensAreTruncated(true);\n      }\n    }, 0);\n  };\n  const handleInputKeyDown = e => {\n    var _ref$current3;\n    if (onKeyDown) {\n      onKeyDown(e);\n    }\n    if ((_ref$current3 = ref.current) !== null && _ref$current3 !== void 0 && _ref$current3.value) {\n      return;\n    }\n    const lastToken = tokens[tokens.length - 1];\n    if (e.key === 'Backspace' && lastToken) {\n      handleTokenRemove(lastToken.id);\n      if (ref.current) {\n        // TODO: eliminate the first hack by making changes to the Autocomplete component\n        //\n        // HACKS:\n        // 1. Directly setting `ref.current.value` instead of updating state because the autocomplete\n        //    highlight behavior doesn't work correctly if we update the value with a setState action in onChange\n        // 2. Adding an extra space so that when I backspace, it doesn't delete the last letter\n        ref.current.value = `${lastToken.text} `;\n      }\n\n      // HACK: for some reason we need to wait a tick for `.select()` to work\n      setTimeout(() => {\n        var _ref$current4;\n        (_ref$current4 = ref.current) === null || _ref$current4 === void 0 ? void 0 : _ref$current4.select();\n      }, 0);\n    }\n  };\n  const focusInput = () => {\n    var _ref$current5;\n    (_ref$current5 = ref.current) === null || _ref$current5 === void 0 ? void 0 : _ref$current5.focus();\n  };\n  const preventTokenClickPropagation = event => {\n    event.stopPropagation();\n  };\n  const visibleTokens = tokensAreTruncated ? tokens.slice(0, visibleTokenCount) : tokens;\n  const inputSizeMap = {\n    small: 'small',\n    medium: 'small',\n    large: 'medium',\n    extralarge: 'medium',\n    xlarge: 'medium' // will eventually replace \"extralarge\" per this ADR: https://github.com/github/primer/blob/main/adrs/2022-02-09-size-naming-guidelines.md\n  };\n\n  const showLeadingLoadingIndicator = loading && (loaderPosition === 'leading' || Boolean(LeadingVisual && loaderPosition !== 'trailing'));\n  const showTrailingLoadingIndicator = loading && (loaderPosition === 'trailing' || loaderPosition === 'auto' && !LeadingVisual);\n  return /*#__PURE__*/React__default.createElement(TextInputWrapper, {\n    block: block,\n    className: className,\n    contrast: contrast,\n    disabled: disabled,\n    hasLeadingVisual: Boolean(LeadingVisual || showLeadingLoadingIndicator),\n    hasTrailingVisual: Boolean(TrailingVisual || showTrailingLoadingIndicator),\n    width: widthProp,\n    minWidth: minWidthProp,\n    maxWidth: maxWidthProp,\n    size: inputSizeMap[size],\n    validationStatus: validationStatus,\n    variant: variantProp // deprecated. use `size` prop instead\n    ,\n    onClick: focusInput,\n    sx: {\n      paddingLeft: textInputHorizPadding,\n      py: `calc(${textInputHorizPadding} / 2)`,\n      ...(block ? {\n        display: 'flex',\n        width: '100%'\n      } : {}),\n      ...(maxHeight ? {\n        maxHeight,\n        overflow: 'auto'\n      } : {}),\n      ...(preventTokenWrapping ? {\n        overflow: 'auto'\n      } : {}),\n      ...sxProp\n    }\n  }, IconComponent && !LeadingVisual && /*#__PURE__*/React__default.createElement(IconComponent, {\n    className: \"TextInput-icon\"\n  }), /*#__PURE__*/React__default.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"leading\",\n    showLoadingIndicator: showLeadingLoadingIndicator\n  }, typeof LeadingVisual === 'function' ? /*#__PURE__*/React__default.createElement(LeadingVisual, null) : LeadingVisual), /*#__PURE__*/React__default.createElement(Box, {\n    ref: containerRef,\n    display: \"flex\",\n    sx: {\n      alignItems: 'center',\n      flexWrap: preventTokenWrapping ? 'nowrap' : 'wrap',\n      marginLeft: '-0.25rem',\n      marginBottom: '-0.25rem',\n      flexGrow: 1,\n      '> *': {\n        flexShrink: 0,\n        marginLeft: '0.25rem',\n        marginBottom: '0.25rem'\n      }\n    }\n  }, /*#__PURE__*/React__default.createElement(Box, {\n    sx: {\n      order: 1,\n      flexGrow: 1\n    }\n  }, /*#__PURE__*/React__default.createElement(UnstyledTextInput, _extends({\n    ref: ref,\n    disabled: disabled,\n    onFocus: handleInputFocus,\n    onBlur: handleInputBlur,\n    onKeyDown: handleInputKeyDown,\n    type: \"text\",\n    sx: {\n      height: '100%'\n    },\n    \"aria-invalid\": validationStatus === 'error' ? 'true' : 'false'\n  }, inputPropsRest))), visibleTokens.map(({\n    id,\n    ...tokenRest\n  }, i) => /*#__PURE__*/React__default.createElement(TokenComponent, _extends({\n    key: id,\n    onFocus: handleTokenFocus(i),\n    onBlur: handleTokenBlur,\n    onKeyUp: handleTokenKeyUp,\n    onClick: preventTokenClickPropagation,\n    isSelected: selectedTokenIndex === i,\n    onRemove: () => {\n      handleTokenRemove(id);\n    },\n    hideRemoveButton: hideTokenRemoveButtons,\n    size: size,\n    tabIndex: 0\n  }, tokenRest))), tokensAreTruncated && tokens.length - visibleTokens.length ? /*#__PURE__*/React__default.createElement(Text, {\n    color: \"fg.muted\",\n    fontSize: overflowCountFontSizeMap[size]\n  }, \"+\", tokens.length - visibleTokens.length) : null), /*#__PURE__*/React__default.createElement(TextInputInnerVisualSlot, {\n    hasLoadingIndicator: typeof loading === 'boolean',\n    visualPosition: \"trailing\",\n    showLoadingIndicator: showTrailingLoadingIndicator\n  }, typeof TrailingVisual === 'function' ? /*#__PURE__*/React__default.createElement(TrailingVisual, null) : TrailingVisual));\n}\nTextInputWithTokensInnerComponent.displayName = \"TextInputWithTokensInnerComponent\";\nconst TextInputWithTokens = /*#__PURE__*/React__default.forwardRef(TextInputWithTokensInnerComponent);\nTextInputWithTokens.displayName = 'TextInputWithTokens';\nvar TextInputWithTokens$1 = TextInputWithTokens;\n\nexport { TextInputWithTokens$1 as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}