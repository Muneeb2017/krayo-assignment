{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst DEV_MODE = true;\nconst reservedReactProperties = new Set(['children', 'localName', 'ref', 'style', 'className']);\nconst listenedEvents = new WeakMap();\n/**\n * Adds an event listener for the specified event to the given node. In the\n * React setup, there should only ever be one event listener. Thus, for\n * efficiency only one listener is added and the handler for that listener is\n * updated to point to the given listener function.\n */\nconst addOrUpdateEventListener = (node, event, listener) => {\n  let events = listenedEvents.get(node);\n  if (events === undefined) {\n    listenedEvents.set(node, events = new Map());\n  }\n  let handler = events.get(event);\n  if (listener !== undefined) {\n    // If necessary, add listener and track handler\n    if (handler === undefined) {\n      events.set(event, handler = {\n        handleEvent: listener\n      });\n      node.addEventListener(event, handler);\n      // Otherwise just update the listener with new value\n    } else {\n      handler.handleEvent = listener;\n    }\n    // Remove listener if one exists and value is undefined\n  } else if (handler !== undefined) {\n    events.delete(event);\n    node.removeEventListener(event, handler);\n  }\n};\n/**\n * Sets properties and events on custom elements. These properties and events\n * have been pre-filtered so we know they should apply to the custom element.\n */\nconst setProperty = (node, name, value, old, events) => {\n  const event = events === null || events === void 0 ? void 0 : events[name];\n  if (event !== undefined && value !== old) {\n    // Dirty check event value.\n    addOrUpdateEventListener(node, event, value);\n    return;\n  }\n  // Note, the attribute removal here for `undefined` and `null` values is done\n  // to match React's behavior on non-custom elements. It needs special\n  // handling because it does not match platform behavior.  For example,\n  // setting the `id` property to `undefined` sets the attribute to the string\n  // \"undefined.\" React \"fixes\" that odd behavior and the code here matches\n  // React's convention.\n  if ((value === undefined || value === null) && name in HTMLElement.prototype) {\n    node.removeAttribute(name);\n    return;\n  }\n  // But don't dirty check properties; elements are assumed to do this.\n  node[name] = value;\n};\n// Set a React ref. Note, there are 2 kinds of refs and there's no built in\n// React API to set a ref.\nconst setRef = (ref, value) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else {\n    ref.current = value;\n  }\n};\nexport function createComponent() {\n  let ReactOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.React;\n  let tagName = arguments.length > 1 ? arguments[1] : undefined;\n  let elementClass = arguments.length > 2 ? arguments[2] : undefined;\n  let events = arguments.length > 3 ? arguments[3] : undefined;\n  let displayName = arguments.length > 4 ? arguments[4] : undefined;\n  // digest overloaded parameters\n  let React;\n  let tag;\n  let element;\n  if (tagName === undefined) {\n    const options = ReactOrOptions;\n    ({\n      tagName: tag,\n      elementClass: element,\n      events,\n      displayName\n    } = options);\n    React = options.react;\n  } else {\n    React = ReactOrOptions;\n    element = elementClass;\n    tag = tagName;\n  }\n  // Warn users when web components use reserved React properties\n  if (DEV_MODE) {\n    for (const p of reservedReactProperties) {\n      if (p in element.prototype && !(p in HTMLElement.prototype)) {\n        // Note, this effectively warns only for `ref` since the other\n        // reserved props are on HTMLElement.prototype. To address this\n        // would require crawling down the prototype, which doesn't feel worth\n        // it since implementing these properties on an element is extremely\n        // rare.\n        console.warn(`${tagName} contains property ${p} which is a React\nreserved property. It will be used by React and not set on\nthe element.`);\n      }\n    }\n  }\n  const Component = React.Component;\n  const createElement = React.createElement;\n  const eventProps = new Set(Object.keys(events !== null && events !== void 0 ? events : {}));\n  class ReactComponent extends Component {\n    constructor() {\n      super(...arguments);\n      this._element = null;\n    }\n    _updateElement(oldProps) {\n      if (this._element === null) {\n        return;\n      }\n      // Set element properties to the values in `this.props`\n      for (const prop in this._elementProps) {\n        setProperty(this._element, prop, this.props[prop], oldProps ? oldProps[prop] : undefined, events);\n      }\n      // Note, the spirit of React might be to \"unset\" any old values that\n      // are no longer included; however, there's no reasonable value to set\n      // them to so we just leave the previous state as is.\n    }\n    /**\n     * Updates element properties correctly setting properties\n     * on mount.\n     */\n    componentDidMount() {\n      this._updateElement();\n    }\n    /**\n     * Updates element properties correctly setting properties\n     * on every update. Note, this does not include mount.\n     */\n    componentDidUpdate(old) {\n      this._updateElement(old);\n    }\n    /**\n     * Renders the custom element with a `ref` prop which allows this\n     * component to reference the custom element.\n     *\n     * Standard attributes are passed to React and element properties and events\n     * are updated in componentDidMount/componentDidUpdate.\n     *\n     */\n    render() {\n      // Extract and remove __forwardedRef from userProps in a rename-safe way\n      const {\n        __forwardedRef,\n        ...userProps\n      } = this.props;\n      // Since refs only get fulfilled once, pass a new one if the user's ref\n      // changed. This allows refs to be fulfilled as expected, going from\n      // having a value to null.\n      if (this._forwardedRef !== __forwardedRef) {\n        this._ref = value => {\n          if (__forwardedRef !== null) {\n            setRef(__forwardedRef, value);\n          }\n          this._element = value;\n          this._forwardedRef = __forwardedRef;\n        };\n      }\n      // Save element props while iterating to avoid the need to iterate again\n      // when setting properties.\n      this._elementProps = {};\n      const props = {\n        ref: this._ref\n      };\n      // Filters class properties and event properties out and passes the\n      // remaining attributes to React. This allows attributes to use framework\n      // rules for setting attributes and render correctly under SSR.\n      for (const [k, v] of Object.entries(userProps)) {\n        if (reservedReactProperties.has(k)) {\n          // React does *not* handle `className` for custom elements so\n          // coerce it to `class` so it's handled correctly.\n          props[k === 'className' ? 'class' : k] = v;\n          continue;\n        }\n        if (eventProps.has(k) || k in element.prototype) {\n          this._elementProps[k] = v;\n          continue;\n        }\n        props[k] = v;\n      }\n      return createElement(tag, props);\n    }\n  }\n  ReactComponent.displayName = displayName !== null && displayName !== void 0 ? displayName : element.name;\n  const ForwardedComponent = React.forwardRef((props, __forwardedRef) => createElement(ReactComponent, {\n    ...props,\n    __forwardedRef\n  }, props === null || props === void 0 ? void 0 : props.children));\n  // To ease debugging in the React Developer Tools\n  ForwardedComponent.displayName = ReactComponent.displayName;\n  return ForwardedComponent;\n}","map":{"version":3,"names":["DEV_MODE","reservedReactProperties","Set","listenedEvents","WeakMap","addOrUpdateEventListener","node","event","listener","events","get","undefined","set","Map","handler","handleEvent","addEventListener","delete","removeEventListener","setProperty","name","value","old","HTMLElement","prototype","removeAttribute","setRef","ref","current","createComponent","ReactOrOptions","arguments","length","window","React","tagName","elementClass","displayName","tag","element","options","react","p","console","warn","Component","createElement","eventProps","Object","keys","ReactComponent","constructor","_element","_updateElement","oldProps","prop","_elementProps","props","componentDidMount","componentDidUpdate","render","__forwardedRef","userProps","_forwardedRef","_ref","k","v","entries","has","ForwardedComponent","forwardRef","children"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@lit-labs/react/src/create-component.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n// Match a prop name to a typed event callback by\n// adding an Event type as an expected property on a string.\nexport type EventName<T extends Event = Event> = string & {\n  __event_type: T;\n};\n\n// A key value map matching React prop names to event names\ntype EventNames = Record<string, EventName | string>;\n\n// A map of expected event listener types based on EventNames\ntype EventListeners<R extends EventNames> = {\n  [K in keyof R]: R[K] extends EventName\n    ? (e: R[K]['__event_type']) => void\n    : (e: Event) => void;\n};\n\ntype ReactProps<I, E> = Omit<React.HTMLAttributes<I>, keyof E>;\ntype ElementWithoutPropsOrEventListeners<I, E> = Omit<\n  I,\n  keyof E | keyof ReactProps<I, E>\n>;\n\n// Props the user is allowed to use, includes standard attributes, children,\n// ref, as well as special event and element properties.\nexport type WebComponentProps<\n  I extends HTMLElement,\n  E extends EventNames = {}\n> = Partial<\n  ReactProps<I, E> &\n    ElementWithoutPropsOrEventListeners<I, E> &\n    EventListeners<E>\n>;\n\n// Props used by this component wrapper. This is the WebComponentProps and the\n// special `__forwardedRef` property. Note, this ref is special because\n// it's both needed in this component to get access to the rendered element\n// and must fulfill any ref passed by the user.\ntype ReactComponentProps<\n  I extends HTMLElement,\n  E extends EventNames = {}\n> = WebComponentProps<I, E> & {\n  __forwardedRef: React.Ref<I>;\n};\n\nexport type ReactWebComponent<\n  I extends HTMLElement,\n  E extends EventNames = {}\n> = React.ForwardRefExoticComponent<\n  React.PropsWithoutRef<WebComponentProps<I, E>> & React.RefAttributes<I>\n>;\n\ninterface Options<I extends HTMLElement, E extends EventNames = {}> {\n  tagName: string;\n  elementClass: Constructor<I>;\n  react: typeof window.React;\n  events?: E;\n  displayName?: string;\n}\n\ntype Constructor<T> = {new (): T};\n\nconst DEV_MODE = true;\n\nconst reservedReactProperties = new Set([\n  'children',\n  'localName',\n  'ref',\n  'style',\n  'className',\n]);\n\nconst listenedEvents: WeakMap<\n  Element,\n  Map<string, EventListenerObject>\n> = new WeakMap();\n\n/**\n * Adds an event listener for the specified event to the given node. In the\n * React setup, there should only ever be one event listener. Thus, for\n * efficiency only one listener is added and the handler for that listener is\n * updated to point to the given listener function.\n */\nconst addOrUpdateEventListener = (\n  node: Element,\n  event: string,\n  listener: (event?: Event) => void\n) => {\n  let events = listenedEvents.get(node);\n  if (events === undefined) {\n    listenedEvents.set(node, (events = new Map()));\n  }\n  let handler = events.get(event);\n  if (listener !== undefined) {\n    // If necessary, add listener and track handler\n    if (handler === undefined) {\n      events.set(event, (handler = {handleEvent: listener}));\n      node.addEventListener(event, handler);\n      // Otherwise just update the listener with new value\n    } else {\n      handler.handleEvent = listener;\n    }\n    // Remove listener if one exists and value is undefined\n  } else if (handler !== undefined) {\n    events.delete(event);\n    node.removeEventListener(event, handler);\n  }\n};\n\n/**\n * Sets properties and events on custom elements. These properties and events\n * have been pre-filtered so we know they should apply to the custom element.\n */\nconst setProperty = <E extends Element>(\n  node: E,\n  name: string,\n  value: unknown,\n  old: unknown,\n  events?: EventNames\n) => {\n  const event = events?.[name];\n  if (event !== undefined && value !== old) {\n    // Dirty check event value.\n    addOrUpdateEventListener(node, event, value as (e?: Event) => void);\n    return;\n  }\n\n  // Note, the attribute removal here for `undefined` and `null` values is done\n  // to match React's behavior on non-custom elements. It needs special\n  // handling because it does not match platform behavior.  For example,\n  // setting the `id` property to `undefined` sets the attribute to the string\n  // \"undefined.\" React \"fixes\" that odd behavior and the code here matches\n  // React's convention.\n  if (\n    (value === undefined || value === null) &&\n    name in HTMLElement.prototype\n  ) {\n    node.removeAttribute(name);\n    return;\n  }\n\n  // But don't dirty check properties; elements are assumed to do this.\n  node[name as keyof E] = value as E[keyof E];\n};\n\n// Set a React ref. Note, there are 2 kinds of refs and there's no built in\n// React API to set a ref.\nconst setRef = (ref: React.Ref<unknown>, value: Element | null) => {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else {\n    (ref as {current: Element | null}).current = value;\n  }\n};\n\n/**\n * Creates a React component for a custom element. Properties are distinguished\n * from attributes automatically, and events can be configured so they are\n * added to the custom element as event listeners.\n *\n * @param options An options bag containing the parameters needed to generate\n * a wrapped web component.\n *\n * @param options.react The React module, typically imported from the `react` npm\n * package.\n * @param options.tagName The custom element tag name registered via\n * `customElements.define`.\n * @param options.elementClass The custom element class registered via\n * `customElements.define`.\n * @param options.events An object listing events to which the component can listen. The\n * object keys are the event property names passed in via React props and the\n * object values are the names of the corresponding events generated by the\n * custom element. For example, given `{onactivate: 'activate'}` an event\n * function may be passed via the component's `onactivate` prop and will be\n * called when the custom element fires its `activate` event.\n * @param options.displayName A React component display name, used in debugging\n * messages. Default value is inferred from the name of custom element class\n * registered via `customElements.define`.\n */\nexport function createComponent<\n  I extends HTMLElement,\n  E extends EventNames = {}\n>(options: Options<I, E>): ReactWebComponent<I, E>;\n/**\n * @deprecated Use `createComponent(options)` instead of individual arguments.\n *\n * Creates a React component for a custom element. Properties are distinguished\n * from attributes automatically, and events can be configured so they are\n * added to the custom element as event listeners.\n *\n * @param React The React module, typically imported from the `react` npm\n * package.\n * @param tagName The custom element tag name registered via\n * `customElements.define`.\n * @param elementClass The custom element class registered via\n * `customElements.define`.\n * @param events An object listing events to which the component can listen. The\n * object keys are the event property names passed in via React props and the\n * object values are the names of the corresponding events generated by the\n * custom element. For example, given `{onactivate: 'activate'}` an event\n * function may be passed via the component's `onactivate` prop and will be\n * called when the custom element fires its `activate` event.\n * @param displayName A React component display name, used in debugging\n * messages. Default value is inferred from the name of custom element class\n * registered via `customElements.define`.\n */\nexport function createComponent<\n  I extends HTMLElement,\n  E extends EventNames = {}\n>(\n  ReactOrOptions: typeof window.React,\n  tagName: string,\n  elementClass: Constructor<I>,\n  events?: E,\n  displayName?: string\n): ReactWebComponent<I, E>;\nexport function createComponent<\n  I extends HTMLElement,\n  E extends EventNames = {}\n>(\n  ReactOrOptions: typeof window.React | Options<I, E> = window.React,\n  tagName?: string,\n  elementClass?: Constructor<I>,\n  events?: E,\n  displayName?: string\n): ReactWebComponent<I, E> {\n  // digest overloaded parameters\n  let React: typeof window.React;\n  let tag: string;\n  let element: Constructor<I>;\n  if (tagName === undefined) {\n    const options = ReactOrOptions as Options<I, E>;\n    ({tagName: tag, elementClass: element, events, displayName} = options);\n    React = options.react;\n  } else {\n    React = ReactOrOptions as typeof window.React;\n    element = elementClass as Constructor<I>;\n    tag = tagName;\n  }\n\n  // Warn users when web components use reserved React properties\n  if (DEV_MODE) {\n    for (const p of reservedReactProperties) {\n      if (p in element.prototype && !(p in HTMLElement.prototype)) {\n        // Note, this effectively warns only for `ref` since the other\n        // reserved props are on HTMLElement.prototype. To address this\n        // would require crawling down the prototype, which doesn't feel worth\n        // it since implementing these properties on an element is extremely\n        // rare.\n        console.warn(`${tagName} contains property ${p} which is a React\nreserved property. It will be used by React and not set on\nthe element.`);\n      }\n    }\n  }\n\n  const Component = React.Component;\n  const createElement = React.createElement;\n  const eventProps = new Set(Object.keys(events ?? {}));\n\n  type Props = ReactComponentProps<I, E>;\n\n  class ReactComponent extends Component<Props> {\n    private _element: I | null = null;\n    private _elementProps!: Record<string, unknown>;\n    private _forwardedRef?: React.Ref<I>;\n    private _ref?: React.RefCallback<I>;\n\n    static displayName = displayName ?? element.name;\n\n    private _updateElement(oldProps?: Props) {\n      if (this._element === null) {\n        return;\n      }\n      // Set element properties to the values in `this.props`\n      for (const prop in this._elementProps) {\n        setProperty(\n          this._element,\n          prop,\n          this.props[prop],\n          oldProps ? oldProps[prop] : undefined,\n          events\n        );\n      }\n      // Note, the spirit of React might be to \"unset\" any old values that\n      // are no longer included; however, there's no reasonable value to set\n      // them to so we just leave the previous state as is.\n    }\n\n    /**\n     * Updates element properties correctly setting properties\n     * on mount.\n     */\n    override componentDidMount() {\n      this._updateElement();\n    }\n\n    /**\n     * Updates element properties correctly setting properties\n     * on every update. Note, this does not include mount.\n     */\n    override componentDidUpdate(old: Props) {\n      this._updateElement(old);\n    }\n\n    /**\n     * Renders the custom element with a `ref` prop which allows this\n     * component to reference the custom element.\n     *\n     * Standard attributes are passed to React and element properties and events\n     * are updated in componentDidMount/componentDidUpdate.\n     *\n     */\n    override render() {\n      // Extract and remove __forwardedRef from userProps in a rename-safe way\n      const {__forwardedRef, ...userProps} = this.props;\n      // Since refs only get fulfilled once, pass a new one if the user's ref\n      // changed. This allows refs to be fulfilled as expected, going from\n      // having a value to null.\n      if (this._forwardedRef !== __forwardedRef) {\n        this._ref = (value: I | null) => {\n          if (__forwardedRef !== null) {\n            setRef(__forwardedRef, value);\n          }\n\n          this._element = value;\n          this._forwardedRef = __forwardedRef;\n        };\n      }\n      // Save element props while iterating to avoid the need to iterate again\n      // when setting properties.\n      this._elementProps = {};\n      const props: Record<string, unknown> = {ref: this._ref};\n      // Filters class properties and event properties out and passes the\n      // remaining attributes to React. This allows attributes to use framework\n      // rules for setting attributes and render correctly under SSR.\n      for (const [k, v] of Object.entries(userProps)) {\n        if (reservedReactProperties.has(k)) {\n          // React does *not* handle `className` for custom elements so\n          // coerce it to `class` so it's handled correctly.\n          props[k === 'className' ? 'class' : k] = v;\n          continue;\n        }\n\n        if (eventProps.has(k) || k in element.prototype) {\n          this._elementProps[k] = v;\n          continue;\n        }\n\n        props[k] = v;\n      }\n      return createElement<React.HTMLAttributes<I>, I>(tag, props);\n    }\n  }\n\n  const ForwardedComponent: ReactWebComponent<I, E> = React.forwardRef<\n    I,\n    WebComponentProps<I, E>\n  >((props, __forwardedRef) =>\n    createElement<Props, ReactComponent, typeof ReactComponent>(\n      ReactComponent,\n      {...props, __forwardedRef},\n      props?.children\n    )\n  );\n\n  // To ease debugging in the React Developer Tools\n  ForwardedComponent.displayName = ReactComponent.displayName;\n\n  return ForwardedComponent;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}