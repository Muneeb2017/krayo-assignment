{"ast":null,"code":"import React__default from 'react';\nimport { iterateFocusableElements } from '@primer/behaviors/utils';\nconst useMenuInitialFocus = (open, containerRef, anchorRef) => {\n  /**\n   * We need to pick the first element to focus based on how the menu was opened,\n   * however, we need to wait for the menu to be open to set focus.\n   * This is why we use set openingKey in state and have 2 effects\n   */\n  const [openingGesture, setOpeningGesture] = React__default.useState(undefined);\n  React__default.useEffect(function inferOpeningKey() {\n    const anchorElement = anchorRef.current;\n    const clickHandler = event => {\n      // event.detail === 0 means onClick was fired by Enter/Space key\n      // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n      if (event.detail !== 0) setOpeningGesture('mouse-click');\n    };\n    const keydownHandler = event => {\n      if (['Space', 'Enter', 'ArrowDown', 'ArrowUp'].includes(event.code)) {\n        setOpeningGesture(event.code);\n      }\n    };\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('click', clickHandler);\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('keydown', keydownHandler);\n    return () => {\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('click', clickHandler);\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('keydown', keydownHandler);\n    };\n  }, [anchorRef]);\n\n  /**\n   * Pick the first element to focus based on the key used to open the Menu\n   * Click: anchor\n   * ArrowDown | Space | Enter: first element\n   * ArrowUp: last element\n   */\n  React__default.useEffect(function moveFocusOnOpen() {\n    if (!open || !containerRef.current) return; // wait till the menu is open\n\n    const iterable = iterateFocusableElements(containerRef.current);\n    if (openingGesture === 'mouse-click') {\n      if (anchorRef.current) anchorRef.current.focus();else throw new Error('For focus management, please attach anchorRef');\n    } else if (openingGesture && ['ArrowDown', 'Space', 'Enter'].includes(openingGesture)) {\n      const firstElement = iterable.next().value;\n      /** We push imperative focus to the next tick to prevent React's batching */\n      setTimeout(() => firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus());\n    } else if ('ArrowUp' === openingGesture) {\n      const elements = [...iterable];\n      const lastElement = elements[elements.length - 1];\n      setTimeout(() => lastElement.focus());\n    } else {\n      /** if the menu was not opened with the anchor, we default to the first element\n       *  for example: with keyboard shortcut (see stories/fixtures)\n       */\n      const firstElement = iterable.next().value;\n      setTimeout(() => firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus());\n    }\n  },\n  // we don't want containerRef in dependencies\n  // because re-renders to containerRef while it's open should not fire initialMenuFocus\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [open, openingGesture, anchorRef]);\n};\nexport { useMenuInitialFocus };","map":{"version":3,"names":["React__default","iterateFocusableElements","useMenuInitialFocus","open","containerRef","anchorRef","openingGesture","setOpeningGesture","useState","undefined","useEffect","inferOpeningKey","anchorElement","current","clickHandler","event","detail","keydownHandler","includes","code","addEventListener","removeEventListener","moveFocusOnOpen","iterable","focus","Error","firstElement","next","value","setTimeout","elements","lastElement","length"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/hooks/useMenuInitialFocus.js"],"sourcesContent":["import React__default from 'react';\nimport { iterateFocusableElements } from '@primer/behaviors/utils';\n\nconst useMenuInitialFocus = (open, containerRef, anchorRef) => {\n  /**\n   * We need to pick the first element to focus based on how the menu was opened,\n   * however, we need to wait for the menu to be open to set focus.\n   * This is why we use set openingKey in state and have 2 effects\n   */\n  const [openingGesture, setOpeningGesture] = React__default.useState(undefined);\n  React__default.useEffect(function inferOpeningKey() {\n    const anchorElement = anchorRef.current;\n    const clickHandler = event => {\n      // event.detail === 0 means onClick was fired by Enter/Space key\n      // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/detail\n      if (event.detail !== 0) setOpeningGesture('mouse-click');\n    };\n    const keydownHandler = event => {\n      if (['Space', 'Enter', 'ArrowDown', 'ArrowUp'].includes(event.code)) {\n        setOpeningGesture(event.code);\n      }\n    };\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('click', clickHandler);\n    anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.addEventListener('keydown', keydownHandler);\n    return () => {\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('click', clickHandler);\n      anchorElement === null || anchorElement === void 0 ? void 0 : anchorElement.removeEventListener('keydown', keydownHandler);\n    };\n  }, [anchorRef]);\n\n  /**\n   * Pick the first element to focus based on the key used to open the Menu\n   * Click: anchor\n   * ArrowDown | Space | Enter: first element\n   * ArrowUp: last element\n   */\n  React__default.useEffect(function moveFocusOnOpen() {\n    if (!open || !containerRef.current) return; // wait till the menu is open\n\n    const iterable = iterateFocusableElements(containerRef.current);\n    if (openingGesture === 'mouse-click') {\n      if (anchorRef.current) anchorRef.current.focus();else throw new Error('For focus management, please attach anchorRef');\n    } else if (openingGesture && ['ArrowDown', 'Space', 'Enter'].includes(openingGesture)) {\n      const firstElement = iterable.next().value;\n      /** We push imperative focus to the next tick to prevent React's batching */\n      setTimeout(() => firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus());\n    } else if ('ArrowUp' === openingGesture) {\n      const elements = [...iterable];\n      const lastElement = elements[elements.length - 1];\n      setTimeout(() => lastElement.focus());\n    } else {\n      /** if the menu was not opened with the anchor, we default to the first element\n       *  for example: with keyboard shortcut (see stories/fixtures)\n       */\n      const firstElement = iterable.next().value;\n      setTimeout(() => firstElement === null || firstElement === void 0 ? void 0 : firstElement.focus());\n    }\n  },\n  // we don't want containerRef in dependencies\n  // because re-renders to containerRef while it's open should not fire initialMenuFocus\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [open, openingGesture, anchorRef]);\n};\n\nexport { useMenuInitialFocus };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}