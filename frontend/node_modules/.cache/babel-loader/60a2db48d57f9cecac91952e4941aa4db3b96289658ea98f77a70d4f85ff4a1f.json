{"ast":null,"code":"const alternateOrders = {\n  'outside-top': ['outside-bottom', 'outside-right', 'outside-left', 'outside-bottom'],\n  'outside-bottom': ['outside-top', 'outside-right', 'outside-left', 'outside-bottom'],\n  'outside-left': ['outside-right', 'outside-bottom', 'outside-top', 'outside-bottom'],\n  'outside-right': ['outside-left', 'outside-bottom', 'outside-top', 'outside-bottom']\n};\nconst alternateAlignments = {\n  start: ['end', 'center'],\n  end: ['start', 'center'],\n  center: ['end', 'start']\n};\nexport function getAnchoredPosition(floatingElement, anchorElement) {\n  let settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const parentElement = getPositionedParent(floatingElement);\n  const clippingRect = getClippingRect(parentElement);\n  const parentElementStyle = getComputedStyle(parentElement);\n  const parentElementRect = parentElement.getBoundingClientRect();\n  const [borderTop, borderLeft] = [parentElementStyle.borderTopWidth, parentElementStyle.borderLeftWidth].map(v => parseInt(v, 10) || 0);\n  const relativeRect = {\n    top: parentElementRect.top + borderTop,\n    left: parentElementRect.left + borderLeft\n  };\n  return pureCalculateAnchoredPosition(clippingRect, relativeRect, floatingElement.getBoundingClientRect(), anchorElement instanceof Element ? anchorElement.getBoundingClientRect() : anchorElement, getDefaultSettings(settings));\n}\nfunction getPositionedParent(element) {\n  let parentNode = element.parentNode;\n  while (parentNode !== null) {\n    if (parentNode instanceof HTMLElement && getComputedStyle(parentNode).position !== 'static') {\n      return parentNode;\n    }\n    parentNode = parentNode.parentNode;\n  }\n  return document.body;\n}\nfunction getClippingRect(element) {\n  let parentNode = element;\n  while (parentNode !== null) {\n    if (parentNode === document.body) {\n      break;\n    }\n    const parentNodeStyle = getComputedStyle(parentNode);\n    if (parentNodeStyle.overflow !== 'visible') {\n      break;\n    }\n    parentNode = parentNode.parentNode;\n  }\n  const clippingNode = parentNode === document.body || !(parentNode instanceof HTMLElement) ? document.body : parentNode;\n  const elemRect = clippingNode.getBoundingClientRect();\n  const elemStyle = getComputedStyle(clippingNode);\n  const [borderTop, borderLeft, borderRight, borderBottom] = [elemStyle.borderTopWidth, elemStyle.borderLeftWidth, elemStyle.borderRightWidth, elemStyle.borderBottomWidth].map(v => parseInt(v, 10) || 0);\n  return {\n    top: elemRect.top + borderTop,\n    left: elemRect.left + borderLeft,\n    width: elemRect.width - borderRight - borderLeft,\n    height: Math.max(elemRect.height - borderTop - borderBottom, clippingNode === document.body ? window.innerHeight : -Infinity)\n  };\n}\nconst positionDefaults = {\n  side: 'outside-bottom',\n  align: 'start',\n  anchorOffset: 4,\n  alignmentOffset: 4,\n  allowOutOfBounds: false\n};\nfunction getDefaultSettings() {\n  let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _a, _b, _c, _d, _e;\n  const side = (_a = settings.side) !== null && _a !== void 0 ? _a : positionDefaults.side;\n  const align = (_b = settings.align) !== null && _b !== void 0 ? _b : positionDefaults.align;\n  return {\n    side,\n    align,\n    anchorOffset: (_c = settings.anchorOffset) !== null && _c !== void 0 ? _c : side === 'inside-center' ? 0 : positionDefaults.anchorOffset,\n    alignmentOffset: (_d = settings.alignmentOffset) !== null && _d !== void 0 ? _d : align !== 'center' && side.startsWith('inside') ? positionDefaults.alignmentOffset : 0,\n    allowOutOfBounds: (_e = settings.allowOutOfBounds) !== null && _e !== void 0 ? _e : positionDefaults.allowOutOfBounds\n  };\n}\nfunction pureCalculateAnchoredPosition(viewportRect, relativePosition, floatingRect, anchorRect, _ref) {\n  let {\n    side,\n    align,\n    allowOutOfBounds,\n    anchorOffset,\n    alignmentOffset\n  } = _ref;\n  const relativeViewportRect = {\n    top: viewportRect.top - relativePosition.top,\n    left: viewportRect.left - relativePosition.left,\n    width: viewportRect.width,\n    height: viewportRect.height\n  };\n  let pos = calculatePosition(floatingRect, anchorRect, side, align, anchorOffset, alignmentOffset);\n  let anchorSide = side;\n  let anchorAlign = align;\n  pos.top -= relativePosition.top;\n  pos.left -= relativePosition.left;\n  if (!allowOutOfBounds) {\n    const alternateOrder = alternateOrders[side];\n    let positionAttempt = 0;\n    if (alternateOrder) {\n      let prevSide = side;\n      while (positionAttempt < alternateOrder.length && shouldRecalculatePosition(prevSide, pos, relativeViewportRect, floatingRect)) {\n        const nextSide = alternateOrder[positionAttempt++];\n        prevSide = nextSide;\n        pos = calculatePosition(floatingRect, anchorRect, nextSide, align, anchorOffset, alignmentOffset);\n        pos.top -= relativePosition.top;\n        pos.left -= relativePosition.left;\n        anchorSide = nextSide;\n      }\n    }\n    const alternateAlignment = alternateAlignments[align];\n    let alignmentAttempt = 0;\n    if (alternateAlignment) {\n      let prevAlign = align;\n      while (alignmentAttempt < alternateAlignment.length && shouldRecalculateAlignment(prevAlign, pos, relativeViewportRect, floatingRect)) {\n        const nextAlign = alternateAlignment[alignmentAttempt++];\n        prevAlign = nextAlign;\n        pos = calculatePosition(floatingRect, anchorRect, anchorSide, nextAlign, anchorOffset, alignmentOffset);\n        pos.top -= relativePosition.top;\n        pos.left -= relativePosition.left;\n        anchorAlign = nextAlign;\n      }\n    }\n    if (pos.top < relativeViewportRect.top) {\n      pos.top = relativeViewportRect.top;\n    }\n    if (pos.left < relativeViewportRect.left) {\n      pos.left = relativeViewportRect.left;\n    }\n    if (pos.left + floatingRect.width > viewportRect.width + relativeViewportRect.left) {\n      pos.left = viewportRect.width + relativeViewportRect.left - floatingRect.width;\n    }\n    if (alternateOrder && positionAttempt < alternateOrder.length) {\n      if (pos.top + floatingRect.height > viewportRect.height + relativeViewportRect.top) {\n        pos.top = viewportRect.height + relativeViewportRect.top - floatingRect.height;\n      }\n    }\n  }\n  return Object.assign(Object.assign({}, pos), {\n    anchorSide,\n    anchorAlign\n  });\n}\nfunction calculatePosition(elementDimensions, anchorPosition, side, align, anchorOffset, alignmentOffset) {\n  const anchorRight = anchorPosition.left + anchorPosition.width;\n  const anchorBottom = anchorPosition.top + anchorPosition.height;\n  let top = -1;\n  let left = -1;\n  if (side === 'outside-top') {\n    top = anchorPosition.top - anchorOffset - elementDimensions.height;\n  } else if (side === 'outside-bottom') {\n    top = anchorBottom + anchorOffset;\n  } else if (side === 'outside-left') {\n    left = anchorPosition.left - anchorOffset - elementDimensions.width;\n  } else if (side === 'outside-right') {\n    left = anchorRight + anchorOffset;\n  }\n  if (side === 'outside-top' || side === 'outside-bottom') {\n    if (align === 'start') {\n      left = anchorPosition.left + alignmentOffset;\n    } else if (align === 'center') {\n      left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n    } else {\n      left = anchorRight - elementDimensions.width - alignmentOffset;\n    }\n  }\n  if (side === 'outside-left' || side === 'outside-right') {\n    if (align === 'start') {\n      top = anchorPosition.top + alignmentOffset;\n    } else if (align === 'center') {\n      top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n    } else {\n      top = anchorBottom - elementDimensions.height - alignmentOffset;\n    }\n  }\n  if (side === 'inside-top') {\n    top = anchorPosition.top + anchorOffset;\n  } else if (side === 'inside-bottom') {\n    top = anchorBottom - anchorOffset - elementDimensions.height;\n  } else if (side === 'inside-left') {\n    left = anchorPosition.left + anchorOffset;\n  } else if (side === 'inside-right') {\n    left = anchorRight - anchorOffset - elementDimensions.width;\n  } else if (side === 'inside-center') {\n    left = (anchorRight + anchorPosition.left) / 2 - elementDimensions.width / 2 + anchorOffset;\n  }\n  if (side === 'inside-top' || side === 'inside-bottom') {\n    if (align === 'start') {\n      left = anchorPosition.left + alignmentOffset;\n    } else if (align === 'center') {\n      left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n    } else {\n      left = anchorRight - elementDimensions.width - alignmentOffset;\n    }\n  } else if (side === 'inside-left' || side === 'inside-right' || side === 'inside-center') {\n    if (align === 'start') {\n      top = anchorPosition.top + alignmentOffset;\n    } else if (align === 'center') {\n      top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n    } else {\n      top = anchorBottom - elementDimensions.height - alignmentOffset;\n    }\n  }\n  return {\n    top,\n    left\n  };\n}\nfunction shouldRecalculatePosition(side, currentPos, containerDimensions, elementDimensions) {\n  if (side === 'outside-top' || side === 'outside-bottom') {\n    return currentPos.top < containerDimensions.top || currentPos.top + elementDimensions.height > containerDimensions.height + containerDimensions.top;\n  } else {\n    return currentPos.left < containerDimensions.left || currentPos.left + elementDimensions.width > containerDimensions.width + containerDimensions.left;\n  }\n}\nfunction shouldRecalculateAlignment(align, currentPos, containerDimensions, elementDimensions) {\n  if (align === 'end') {\n    return currentPos.left < containerDimensions.left;\n  } else if (align === 'start' || align === 'center') {\n    return currentPos.left + elementDimensions.width > containerDimensions.left + containerDimensions.width || currentPos.left < containerDimensions.left;\n  }\n}","map":{"version":3,"names":["alternateOrders","alternateAlignments","start","end","center","getAnchoredPosition","floatingElement","anchorElement","settings","arguments","length","undefined","parentElement","getPositionedParent","clippingRect","getClippingRect","parentElementStyle","getComputedStyle","parentElementRect","getBoundingClientRect","borderTop","borderLeft","borderTopWidth","borderLeftWidth","map","v","parseInt","relativeRect","top","left","pureCalculateAnchoredPosition","Element","getDefaultSettings","element","parentNode","HTMLElement","position","document","body","parentNodeStyle","overflow","clippingNode","elemRect","elemStyle","borderRight","borderBottom","borderRightWidth","borderBottomWidth","width","height","Math","max","window","innerHeight","Infinity","positionDefaults","side","align","anchorOffset","alignmentOffset","allowOutOfBounds","_a","_b","_c","_d","_e","startsWith","viewportRect","relativePosition","floatingRect","anchorRect","_ref","relativeViewportRect","pos","calculatePosition","anchorSide","anchorAlign","alternateOrder","positionAttempt","prevSide","shouldRecalculatePosition","nextSide","alternateAlignment","alignmentAttempt","prevAlign","shouldRecalculateAlignment","nextAlign","Object","assign","elementDimensions","anchorPosition","anchorRight","anchorBottom","currentPos","containerDimensions"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/behaviors/dist/esm/anchored-position.js"],"sourcesContent":["const alternateOrders = {\n    'outside-top': ['outside-bottom', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-bottom': ['outside-top', 'outside-right', 'outside-left', 'outside-bottom'],\n    'outside-left': ['outside-right', 'outside-bottom', 'outside-top', 'outside-bottom'],\n    'outside-right': ['outside-left', 'outside-bottom', 'outside-top', 'outside-bottom']\n};\nconst alternateAlignments = {\n    start: ['end', 'center'],\n    end: ['start', 'center'],\n    center: ['end', 'start']\n};\nexport function getAnchoredPosition(floatingElement, anchorElement, settings = {}) {\n    const parentElement = getPositionedParent(floatingElement);\n    const clippingRect = getClippingRect(parentElement);\n    const parentElementStyle = getComputedStyle(parentElement);\n    const parentElementRect = parentElement.getBoundingClientRect();\n    const [borderTop, borderLeft] = [parentElementStyle.borderTopWidth, parentElementStyle.borderLeftWidth].map(v => parseInt(v, 10) || 0);\n    const relativeRect = {\n        top: parentElementRect.top + borderTop,\n        left: parentElementRect.left + borderLeft\n    };\n    return pureCalculateAnchoredPosition(clippingRect, relativeRect, floatingElement.getBoundingClientRect(), anchorElement instanceof Element ? anchorElement.getBoundingClientRect() : anchorElement, getDefaultSettings(settings));\n}\nfunction getPositionedParent(element) {\n    let parentNode = element.parentNode;\n    while (parentNode !== null) {\n        if (parentNode instanceof HTMLElement && getComputedStyle(parentNode).position !== 'static') {\n            return parentNode;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    return document.body;\n}\nfunction getClippingRect(element) {\n    let parentNode = element;\n    while (parentNode !== null) {\n        if (parentNode === document.body) {\n            break;\n        }\n        const parentNodeStyle = getComputedStyle(parentNode);\n        if (parentNodeStyle.overflow !== 'visible') {\n            break;\n        }\n        parentNode = parentNode.parentNode;\n    }\n    const clippingNode = parentNode === document.body || !(parentNode instanceof HTMLElement) ? document.body : parentNode;\n    const elemRect = clippingNode.getBoundingClientRect();\n    const elemStyle = getComputedStyle(clippingNode);\n    const [borderTop, borderLeft, borderRight, borderBottom] = [\n        elemStyle.borderTopWidth,\n        elemStyle.borderLeftWidth,\n        elemStyle.borderRightWidth,\n        elemStyle.borderBottomWidth\n    ].map(v => parseInt(v, 10) || 0);\n    return {\n        top: elemRect.top + borderTop,\n        left: elemRect.left + borderLeft,\n        width: elemRect.width - borderRight - borderLeft,\n        height: Math.max(elemRect.height - borderTop - borderBottom, clippingNode === document.body ? window.innerHeight : -Infinity)\n    };\n}\nconst positionDefaults = {\n    side: 'outside-bottom',\n    align: 'start',\n    anchorOffset: 4,\n    alignmentOffset: 4,\n    allowOutOfBounds: false\n};\nfunction getDefaultSettings(settings = {}) {\n    var _a, _b, _c, _d, _e;\n    const side = (_a = settings.side) !== null && _a !== void 0 ? _a : positionDefaults.side;\n    const align = (_b = settings.align) !== null && _b !== void 0 ? _b : positionDefaults.align;\n    return {\n        side,\n        align,\n        anchorOffset: (_c = settings.anchorOffset) !== null && _c !== void 0 ? _c : (side === 'inside-center' ? 0 : positionDefaults.anchorOffset),\n        alignmentOffset: (_d = settings.alignmentOffset) !== null && _d !== void 0 ? _d : (align !== 'center' && side.startsWith('inside') ? positionDefaults.alignmentOffset : 0),\n        allowOutOfBounds: (_e = settings.allowOutOfBounds) !== null && _e !== void 0 ? _e : positionDefaults.allowOutOfBounds\n    };\n}\nfunction pureCalculateAnchoredPosition(viewportRect, relativePosition, floatingRect, anchorRect, { side, align, allowOutOfBounds, anchorOffset, alignmentOffset }) {\n    const relativeViewportRect = {\n        top: viewportRect.top - relativePosition.top,\n        left: viewportRect.left - relativePosition.left,\n        width: viewportRect.width,\n        height: viewportRect.height\n    };\n    let pos = calculatePosition(floatingRect, anchorRect, side, align, anchorOffset, alignmentOffset);\n    let anchorSide = side;\n    let anchorAlign = align;\n    pos.top -= relativePosition.top;\n    pos.left -= relativePosition.left;\n    if (!allowOutOfBounds) {\n        const alternateOrder = alternateOrders[side];\n        let positionAttempt = 0;\n        if (alternateOrder) {\n            let prevSide = side;\n            while (positionAttempt < alternateOrder.length &&\n                shouldRecalculatePosition(prevSide, pos, relativeViewportRect, floatingRect)) {\n                const nextSide = alternateOrder[positionAttempt++];\n                prevSide = nextSide;\n                pos = calculatePosition(floatingRect, anchorRect, nextSide, align, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorSide = nextSide;\n            }\n        }\n        const alternateAlignment = alternateAlignments[align];\n        let alignmentAttempt = 0;\n        if (alternateAlignment) {\n            let prevAlign = align;\n            while (alignmentAttempt < alternateAlignment.length &&\n                shouldRecalculateAlignment(prevAlign, pos, relativeViewportRect, floatingRect)) {\n                const nextAlign = alternateAlignment[alignmentAttempt++];\n                prevAlign = nextAlign;\n                pos = calculatePosition(floatingRect, anchorRect, anchorSide, nextAlign, anchorOffset, alignmentOffset);\n                pos.top -= relativePosition.top;\n                pos.left -= relativePosition.left;\n                anchorAlign = nextAlign;\n            }\n        }\n        if (pos.top < relativeViewportRect.top) {\n            pos.top = relativeViewportRect.top;\n        }\n        if (pos.left < relativeViewportRect.left) {\n            pos.left = relativeViewportRect.left;\n        }\n        if (pos.left + floatingRect.width > viewportRect.width + relativeViewportRect.left) {\n            pos.left = viewportRect.width + relativeViewportRect.left - floatingRect.width;\n        }\n        if (alternateOrder && positionAttempt < alternateOrder.length) {\n            if (pos.top + floatingRect.height > viewportRect.height + relativeViewportRect.top) {\n                pos.top = viewportRect.height + relativeViewportRect.top - floatingRect.height;\n            }\n        }\n    }\n    return Object.assign(Object.assign({}, pos), { anchorSide, anchorAlign });\n}\nfunction calculatePosition(elementDimensions, anchorPosition, side, align, anchorOffset, alignmentOffset) {\n    const anchorRight = anchorPosition.left + anchorPosition.width;\n    const anchorBottom = anchorPosition.top + anchorPosition.height;\n    let top = -1;\n    let left = -1;\n    if (side === 'outside-top') {\n        top = anchorPosition.top - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'outside-bottom') {\n        top = anchorBottom + anchorOffset;\n    }\n    else if (side === 'outside-left') {\n        left = anchorPosition.left - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'outside-right') {\n        left = anchorRight + anchorOffset;\n    }\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    if (side === 'outside-left' || side === 'outside-right') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    if (side === 'inside-top') {\n        top = anchorPosition.top + anchorOffset;\n    }\n    else if (side === 'inside-bottom') {\n        top = anchorBottom - anchorOffset - elementDimensions.height;\n    }\n    else if (side === 'inside-left') {\n        left = anchorPosition.left + anchorOffset;\n    }\n    else if (side === 'inside-right') {\n        left = anchorRight - anchorOffset - elementDimensions.width;\n    }\n    else if (side === 'inside-center') {\n        left = (anchorRight + anchorPosition.left) / 2 - elementDimensions.width / 2 + anchorOffset;\n    }\n    if (side === 'inside-top' || side === 'inside-bottom') {\n        if (align === 'start') {\n            left = anchorPosition.left + alignmentOffset;\n        }\n        else if (align === 'center') {\n            left = anchorPosition.left - (elementDimensions.width - anchorPosition.width) / 2 + alignmentOffset;\n        }\n        else {\n            left = anchorRight - elementDimensions.width - alignmentOffset;\n        }\n    }\n    else if (side === 'inside-left' || side === 'inside-right' || side === 'inside-center') {\n        if (align === 'start') {\n            top = anchorPosition.top + alignmentOffset;\n        }\n        else if (align === 'center') {\n            top = anchorPosition.top - (elementDimensions.height - anchorPosition.height) / 2 + alignmentOffset;\n        }\n        else {\n            top = anchorBottom - elementDimensions.height - alignmentOffset;\n        }\n    }\n    return { top, left };\n}\nfunction shouldRecalculatePosition(side, currentPos, containerDimensions, elementDimensions) {\n    if (side === 'outside-top' || side === 'outside-bottom') {\n        return (currentPos.top < containerDimensions.top ||\n            currentPos.top + elementDimensions.height > containerDimensions.height + containerDimensions.top);\n    }\n    else {\n        return (currentPos.left < containerDimensions.left ||\n            currentPos.left + elementDimensions.width > containerDimensions.width + containerDimensions.left);\n    }\n}\nfunction shouldRecalculateAlignment(align, currentPos, containerDimensions, elementDimensions) {\n    if (align === 'end') {\n        return currentPos.left < containerDimensions.left;\n    }\n    else if (align === 'start' || align === 'center') {\n        return (currentPos.left + elementDimensions.width > containerDimensions.left + containerDimensions.width ||\n            currentPos.left < containerDimensions.left);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}