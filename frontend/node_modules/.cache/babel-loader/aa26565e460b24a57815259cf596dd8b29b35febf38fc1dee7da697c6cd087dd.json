{"ast":null,"code":"import React__default from 'react';\nimport { focusTrap } from '@primer/behaviors';\nimport { useProvidedRefOrCreate } from './useProvidedRefOrCreate.js';\n\n/**\n * Hook used to trap focus inside a container. Returns a ref that can be added to the container\n * that should trap focus.\n * @param settings {FocusTrapHookSettings}\n */\nfunction useFocusTrap(settings) {\n  let dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  const containerRef = useProvidedRefOrCreate(settings === null || settings === void 0 ? void 0 : settings.containerRef);\n  const initialFocusRef = useProvidedRefOrCreate(settings === null || settings === void 0 ? void 0 : settings.initialFocusRef);\n  const disabled = settings === null || settings === void 0 ? void 0 : settings.disabled;\n  const abortController = React__default.useRef();\n  const previousFocusedElement = React__default.useRef(null);\n\n  // If we are enabling a focus trap and haven't already stored the previously focused element\n  // go ahead an do that so we can restore later when the trap is disabled.\n  if (!previousFocusedElement.current && !(settings !== null && settings !== void 0 && settings.disabled)) {\n    previousFocusedElement.current = document.activeElement;\n  }\n\n  // This function removes the event listeners that enable the focus trap and restores focus\n  // to the previously-focused element (if necessary).\n  function disableTrap() {\n    var _abortController$curr;\n    (_abortController$curr = abortController.current) === null || _abortController$curr === void 0 ? void 0 : _abortController$curr.abort();\n    if (settings !== null && settings !== void 0 && settings.restoreFocusOnCleanUp && previousFocusedElement.current instanceof HTMLElement) {\n      previousFocusedElement.current.focus();\n      previousFocusedElement.current = null;\n    }\n  }\n  React__default.useEffect(() => {\n    if (containerRef.current instanceof HTMLElement) {\n      if (!disabled) {\n        var _initialFocusRef$curr;\n        abortController.current = focusTrap(containerRef.current, (_initialFocusRef$curr = initialFocusRef.current) !== null && _initialFocusRef$curr !== void 0 ? _initialFocusRef$curr : undefined);\n        return () => {\n          disableTrap();\n        };\n      } else {\n        disableTrap();\n      }\n    }\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [containerRef, initialFocusRef, disabled, ...dependencies]);\n  return {\n    containerRef,\n    initialFocusRef\n  };\n}\nexport { useFocusTrap };","map":{"version":3,"names":["React__default","focusTrap","useProvidedRefOrCreate","useFocusTrap","settings","dependencies","arguments","length","undefined","containerRef","initialFocusRef","disabled","abortController","useRef","previousFocusedElement","current","document","activeElement","disableTrap","_abortController$curr","abort","restoreFocusOnCleanUp","HTMLElement","focus","useEffect","_initialFocusRef$curr"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/hooks/useFocusTrap.js"],"sourcesContent":["import React__default from 'react';\nimport { focusTrap } from '@primer/behaviors';\nimport { useProvidedRefOrCreate } from './useProvidedRefOrCreate.js';\n\n/**\n * Hook used to trap focus inside a container. Returns a ref that can be added to the container\n * that should trap focus.\n * @param settings {FocusTrapHookSettings}\n */\nfunction useFocusTrap(settings, dependencies = []) {\n  const containerRef = useProvidedRefOrCreate(settings === null || settings === void 0 ? void 0 : settings.containerRef);\n  const initialFocusRef = useProvidedRefOrCreate(settings === null || settings === void 0 ? void 0 : settings.initialFocusRef);\n  const disabled = settings === null || settings === void 0 ? void 0 : settings.disabled;\n  const abortController = React__default.useRef();\n  const previousFocusedElement = React__default.useRef(null);\n\n  // If we are enabling a focus trap and haven't already stored the previously focused element\n  // go ahead an do that so we can restore later when the trap is disabled.\n  if (!previousFocusedElement.current && !(settings !== null && settings !== void 0 && settings.disabled)) {\n    previousFocusedElement.current = document.activeElement;\n  }\n\n  // This function removes the event listeners that enable the focus trap and restores focus\n  // to the previously-focused element (if necessary).\n  function disableTrap() {\n    var _abortController$curr;\n    (_abortController$curr = abortController.current) === null || _abortController$curr === void 0 ? void 0 : _abortController$curr.abort();\n    if (settings !== null && settings !== void 0 && settings.restoreFocusOnCleanUp && previousFocusedElement.current instanceof HTMLElement) {\n      previousFocusedElement.current.focus();\n      previousFocusedElement.current = null;\n    }\n  }\n  React__default.useEffect(() => {\n    if (containerRef.current instanceof HTMLElement) {\n      if (!disabled) {\n        var _initialFocusRef$curr;\n        abortController.current = focusTrap(containerRef.current, (_initialFocusRef$curr = initialFocusRef.current) !== null && _initialFocusRef$curr !== void 0 ? _initialFocusRef$curr : undefined);\n        return () => {\n          disableTrap();\n        };\n      } else {\n        disableTrap();\n      }\n    }\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [containerRef, initialFocusRef, disabled, ...dependencies]);\n  return {\n    containerRef,\n    initialFocusRef\n  };\n}\n\nexport { useFocusTrap };\n"],"mappings":"AAAA,OAAOA,cAAc,MAAM,OAAO;AAClC,SAASC,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,sBAAsB,QAAQ,6BAA6B;;AAEpE;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,QAAQ,EAAqB;EAAA,IAAnBC,YAAY,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,EAAE;EAC/C,MAAMG,YAAY,GAAGP,sBAAsB,CAACE,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACK,YAAY,CAAC;EACtH,MAAMC,eAAe,GAAGR,sBAAsB,CAACE,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACM,eAAe,CAAC;EAC5H,MAAMC,QAAQ,GAAGP,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAACO,QAAQ;EACtF,MAAMC,eAAe,GAAGZ,cAAc,CAACa,MAAM,EAAE;EAC/C,MAAMC,sBAAsB,GAAGd,cAAc,CAACa,MAAM,CAAC,IAAI,CAAC;;EAE1D;EACA;EACA,IAAI,CAACC,sBAAsB,CAACC,OAAO,IAAI,EAAEX,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,IAAIA,QAAQ,CAACO,QAAQ,CAAC,EAAE;IACvGG,sBAAsB,CAACC,OAAO,GAAGC,QAAQ,CAACC,aAAa;EACzD;;EAEA;EACA;EACA,SAASC,WAAWA,CAAA,EAAG;IACrB,IAAIC,qBAAqB;IACzB,CAACA,qBAAqB,GAAGP,eAAe,CAACG,OAAO,MAAM,IAAI,IAAII,qBAAqB,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,qBAAqB,CAACC,KAAK,EAAE;IACvI,IAAIhB,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,IAAIA,QAAQ,CAACiB,qBAAqB,IAAIP,sBAAsB,CAACC,OAAO,YAAYO,WAAW,EAAE;MACvIR,sBAAsB,CAACC,OAAO,CAACQ,KAAK,EAAE;MACtCT,sBAAsB,CAACC,OAAO,GAAG,IAAI;IACvC;EACF;EACAf,cAAc,CAACwB,SAAS,CAAC,MAAM;IAC7B,IAAIf,YAAY,CAACM,OAAO,YAAYO,WAAW,EAAE;MAC/C,IAAI,CAACX,QAAQ,EAAE;QACb,IAAIc,qBAAqB;QACzBb,eAAe,CAACG,OAAO,GAAGd,SAAS,CAACQ,YAAY,CAACM,OAAO,EAAE,CAACU,qBAAqB,GAAGf,eAAe,CAACK,OAAO,MAAM,IAAI,IAAIU,qBAAqB,KAAK,KAAK,CAAC,GAAGA,qBAAqB,GAAGjB,SAAS,CAAC;QAC7L,OAAO,MAAM;UACXU,WAAW,EAAE;QACf,CAAC;MACH,CAAC,MAAM;QACLA,WAAW,EAAE;MACf;IACF;EACF,CAAC;EACD;EACA,CAACT,YAAY,EAAEC,eAAe,EAAEC,QAAQ,EAAE,GAAGN,YAAY,CAAC,CAAC;EAC3D,OAAO;IACLI,YAAY;IACZC;EACF,CAAC;AACH;AAEA,SAASP,YAAY"},"metadata":{},"sourceType":"module","externalDependencies":[]}