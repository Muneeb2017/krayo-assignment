{"ast":null,"code":"import { useCallback } from 'react';\nconst calculateNewCaretPosition = (originalCaretPosition, replaceRange, insertLength) => {\n  const deleteLength = replaceRange[1] - replaceRange[0];\n  const lengthDifference = insertLength - deleteLength;\n\n  // If caret is before the replacement, position is unaffected. If it is at/in the replacement\n  // section, move it to the end (as though the user had selected text and typed\n  // the replacement). If it is after the replacement, move it by the length difference.\n  return originalCaretPosition < replaceRange[0] ? originalCaretPosition : originalCaretPosition < replaceRange[1] ? replaceRange[0] + insertLength : originalCaretPosition + lengthDifference;\n};\n\n/**\n * Builds a fake `React.ChangeEvent` from a dispatched `InputEvent` instance.\n * This is only used as a fallback in cases where browsers don't support `execCommand`.\n */\nconst SyntheticChangeEvent = (dispatchedEvent, target) => ({\n  // Spreading the event is particularly imperfect. Functions called on the `SyntheticEvent`\n  // will have the wrong `this` binding and shallow object properties may fall out of sync.\n  // We consider this acceptable since this is only the fallback behavior, but it's not ideal by any means.\n  ...dispatchedEvent,\n  nativeEvent: dispatchedEvent,\n  target,\n  // `currentTarget` is the element that the event listener is attached to. The event\n  // doesn't know this, so `event.currentTarget` is `null`.\n  currentTarget: target,\n  preventDefault: () => dispatchedEvent.preventDefault(),\n  isDefaultPrevented: () => dispatchedEvent.defaultPrevented,\n  // This event doesn't bubble anyway so there's no need for the consumer to try to\n  // stop propagation\n  isPropagationStopped: () => false,\n  // \"As of v17, e.persist() doesn’t do anything because the SyntheticEvent is no\n  // longer pooled\" -  https://reactjs.org/docs/events.html#overview\n  persist: () => ({\n    /* noop */\n  })\n});\n/**\n * Returns a function that will synthetically change the input, attempting to maintain caret\n * position and undo history as though the user had typed using a keyboard.\n *\n * Will first attempt to use the non-standard browser `execCommmand` API to simulate a typing\n * action. Failing this (ie, in test environments or certain browsers), the fallback handler\n * will be called with a fake constructed `ChangeEvent` that looks like a real event.\n */\nconst useSyntheticChange = _ref => {\n  let {\n    inputRef,\n    fallbackEventHandler\n  } = _ref;\n  return useCallback((insertValue, replaceRange_, newSelection_) => {\n    var _input$selectionStart, _input$selectionEnd, _input$selectionStart2;\n    const input = inputRef.current;\n    if (!input) return;\n    input.focus(); // the input must be focused to execute execCommand\n\n    const replaceRange = replaceRange_ !== null && replaceRange_ !== void 0 ? replaceRange_ : [(_input$selectionStart = input.selectionStart) !== null && _input$selectionStart !== void 0 ? _input$selectionStart : input.value.length, (_input$selectionEnd = input.selectionEnd) !== null && _input$selectionEnd !== void 0 ? _input$selectionEnd : input.value.length];\n    const newSelectionStart = newSelection_ === undefined ? calculateNewCaretPosition((_input$selectionStart2 = input.selectionStart) !== null && _input$selectionStart2 !== void 0 ? _input$selectionStart2 : input.value.length, replaceRange, insertValue.length) : Array.isArray(newSelection_) ? newSelection_[0] : newSelection_;\n    const newSelectionEnd = Array.isArray(newSelection_) ? newSelection_[1] : newSelectionStart;\n\n    // execCommmand simulates the user actually typing the value into the input. This preserves the undo history,\n    // but it's a deprecated API and there's no alternative. It also doesn't work in test environments\n    let execCommandResult = false;\n    try {\n      // expand selection to the whole range and replace it with the new value\n      input.setSelectionRange(replaceRange[0], replaceRange[1]);\n      execCommandResult = insertValue === '' ? document.execCommand('delete', false) : document.execCommand('insertText', false, insertValue);\n      input.setSelectionRange(newSelectionStart, newSelectionEnd);\n    } catch (e) {\n      execCommandResult = false;\n    }\n\n    // If the execCommand method failed, call onChange instead - will nuke the undo history :(\n    if (!execCommandResult) {\n      const newValue = input.value.slice(0, replaceRange[0]) + insertValue + input.value.slice(replaceRange[1]);\n\n      // When building the event we could also define the inputType and data, but that would\n      // be complex for the consumer to maintain. For now that's not functionality that is\n      // strictly necessary.\n      // React SyntheticChangeEvents are actually built around 'input' events, not 'change' events\n      const event = new InputEvent('input', {\n        bubbles: false\n      });\n      inputRef.current.value = newValue;\n      inputRef.current.setSelectionRange(newSelectionStart, newSelectionEnd);\n\n      // Even though we call onChange manually, we must dispatch the event so the browser can\n      // set its `target` and fully create it\n      inputRef.current.dispatchEvent(event);\n\n      // Surprisingly, dispatching the event does not cause React to call handlers, even\n      // though it looks almost exactly like a normal 'input' event. Maybe it's because the\n      // event is not trusted? So we have to build and dispatch the `SyntheticEvent` ourselves.\n      // This is not perfect but it gets pretty close.\n      fallbackEventHandler(SyntheticChangeEvent(event, inputRef.current));\n    }\n  }, [inputRef, fallbackEventHandler]);\n};\nexport { useSyntheticChange };","map":{"version":3,"names":["useCallback","calculateNewCaretPosition","originalCaretPosition","replaceRange","insertLength","deleteLength","lengthDifference","SyntheticChangeEvent","dispatchedEvent","target","nativeEvent","currentTarget","preventDefault","isDefaultPrevented","defaultPrevented","isPropagationStopped","persist","useSyntheticChange","_ref","inputRef","fallbackEventHandler","insertValue","replaceRange_","newSelection_","_input$selectionStart","_input$selectionEnd","_input$selectionStart2","input","current","focus","selectionStart","value","length","selectionEnd","newSelectionStart","undefined","Array","isArray","newSelectionEnd","execCommandResult","setSelectionRange","document","execCommand","e","newValue","slice","event","InputEvent","bubbles","dispatchEvent"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/drafts/hooks/useSyntheticChange.js"],"sourcesContent":["import { useCallback } from 'react';\n\nconst calculateNewCaretPosition = (originalCaretPosition, replaceRange, insertLength) => {\n  const deleteLength = replaceRange[1] - replaceRange[0];\n  const lengthDifference = insertLength - deleteLength;\n\n  // If caret is before the replacement, position is unaffected. If it is at/in the replacement\n  // section, move it to the end (as though the user had selected text and typed\n  // the replacement). If it is after the replacement, move it by the length difference.\n  return originalCaretPosition < replaceRange[0] ? originalCaretPosition : originalCaretPosition < replaceRange[1] ? replaceRange[0] + insertLength : originalCaretPosition + lengthDifference;\n};\n\n/**\n * Builds a fake `React.ChangeEvent` from a dispatched `InputEvent` instance.\n * This is only used as a fallback in cases where browsers don't support `execCommand`.\n */\nconst SyntheticChangeEvent = (dispatchedEvent, target) => ({\n  // Spreading the event is particularly imperfect. Functions called on the `SyntheticEvent`\n  // will have the wrong `this` binding and shallow object properties may fall out of sync.\n  // We consider this acceptable since this is only the fallback behavior, but it's not ideal by any means.\n  ...dispatchedEvent,\n  nativeEvent: dispatchedEvent,\n  target,\n  // `currentTarget` is the element that the event listener is attached to. The event\n  // doesn't know this, so `event.currentTarget` is `null`.\n  currentTarget: target,\n  preventDefault: () => dispatchedEvent.preventDefault(),\n  isDefaultPrevented: () => dispatchedEvent.defaultPrevented,\n  // This event doesn't bubble anyway so there's no need for the consumer to try to\n  // stop propagation\n  isPropagationStopped: () => false,\n  // \"As of v17, e.persist() doesn’t do anything because the SyntheticEvent is no\n  // longer pooled\" -  https://reactjs.org/docs/events.html#overview\n  persist: () => ({\n    /* noop */\n  })\n});\n/**\n * Returns a function that will synthetically change the input, attempting to maintain caret\n * position and undo history as though the user had typed using a keyboard.\n *\n * Will first attempt to use the non-standard browser `execCommmand` API to simulate a typing\n * action. Failing this (ie, in test environments or certain browsers), the fallback handler\n * will be called with a fake constructed `ChangeEvent` that looks like a real event.\n */\nconst useSyntheticChange = ({\n  inputRef,\n  fallbackEventHandler\n}) => useCallback((insertValue, replaceRange_, newSelection_) => {\n  var _input$selectionStart, _input$selectionEnd, _input$selectionStart2;\n  const input = inputRef.current;\n  if (!input) return;\n  input.focus(); // the input must be focused to execute execCommand\n\n  const replaceRange = replaceRange_ !== null && replaceRange_ !== void 0 ? replaceRange_ : [(_input$selectionStart = input.selectionStart) !== null && _input$selectionStart !== void 0 ? _input$selectionStart : input.value.length, (_input$selectionEnd = input.selectionEnd) !== null && _input$selectionEnd !== void 0 ? _input$selectionEnd : input.value.length];\n  const newSelectionStart = newSelection_ === undefined ? calculateNewCaretPosition((_input$selectionStart2 = input.selectionStart) !== null && _input$selectionStart2 !== void 0 ? _input$selectionStart2 : input.value.length, replaceRange, insertValue.length) : Array.isArray(newSelection_) ? newSelection_[0] : newSelection_;\n  const newSelectionEnd = Array.isArray(newSelection_) ? newSelection_[1] : newSelectionStart;\n\n  // execCommmand simulates the user actually typing the value into the input. This preserves the undo history,\n  // but it's a deprecated API and there's no alternative. It also doesn't work in test environments\n  let execCommandResult = false;\n  try {\n    // expand selection to the whole range and replace it with the new value\n    input.setSelectionRange(replaceRange[0], replaceRange[1]);\n    execCommandResult = insertValue === '' ? document.execCommand('delete', false) : document.execCommand('insertText', false, insertValue);\n    input.setSelectionRange(newSelectionStart, newSelectionEnd);\n  } catch (e) {\n    execCommandResult = false;\n  }\n\n  // If the execCommand method failed, call onChange instead - will nuke the undo history :(\n  if (!execCommandResult) {\n    const newValue = input.value.slice(0, replaceRange[0]) + insertValue + input.value.slice(replaceRange[1]);\n\n    // When building the event we could also define the inputType and data, but that would\n    // be complex for the consumer to maintain. For now that's not functionality that is\n    // strictly necessary.\n    // React SyntheticChangeEvents are actually built around 'input' events, not 'change' events\n    const event = new InputEvent('input', {\n      bubbles: false\n    });\n    inputRef.current.value = newValue;\n    inputRef.current.setSelectionRange(newSelectionStart, newSelectionEnd);\n\n    // Even though we call onChange manually, we must dispatch the event so the browser can\n    // set its `target` and fully create it\n    inputRef.current.dispatchEvent(event);\n\n    // Surprisingly, dispatching the event does not cause React to call handlers, even\n    // though it looks almost exactly like a normal 'input' event. Maybe it's because the\n    // event is not trusted? So we have to build and dispatch the `SyntheticEvent` ourselves.\n    // This is not perfect but it gets pretty close.\n    fallbackEventHandler(SyntheticChangeEvent(event, inputRef.current));\n  }\n}, [inputRef, fallbackEventHandler]);\n\nexport { useSyntheticChange };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}