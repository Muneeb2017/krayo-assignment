{"ast":null,"code":"import { useFocusZone } from '../hooks/useFocusZone.js';\nimport { getScrollContainer } from '../utils/scroll.js';\nimport { FocusKeys } from '@primer/behaviors';\nfunction useRovingTabIndex(_ref) {\n  let {\n    containerRef\n  } = _ref;\n  // TODO: Initialize focus to the aria-current item if it exists\n  useFocusZone({\n    containerRef,\n    bindKeys: FocusKeys.ArrowVertical | FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd | FocusKeys.Backspace | FocusKeys.PageUpDown,\n    preventScroll: true,\n    getNextFocusable: (direction, from, event) => {\n      var _getNextFocusableElem;\n      if (!(from instanceof HTMLElement)) return;\n      return (_getNextFocusableElem = getNextFocusableElement(from, event)) !== null && _getNextFocusableElem !== void 0 ? _getNextFocusableElem : from;\n    },\n    focusInStrategy: () => {\n      var _containerRef$current, _containerRef$current2, _containerRef$current3;\n      const currentItem = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelector('[aria-current]');\n      const firstItem = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.querySelector('[role=\"treeitem\"]');\n\n      // Focus the aria-current item if it exists\n      if (currentItem instanceof HTMLElement) {\n        return currentItem;\n      }\n\n      // Otherwise, focus the activeElement if it's a treeitem\n      if (document.activeElement instanceof HTMLElement && (_containerRef$current3 = containerRef.current) !== null && _containerRef$current3 !== void 0 && _containerRef$current3.contains(document.activeElement)) {\n        return document.activeElement;\n      }\n\n      // Otherwise, focus the first treeitem\n      return firstItem instanceof HTMLElement ? firstItem : undefined;\n    }\n  });\n}\n\n// DOM utilities used for focus management\n\nfunction getNextFocusableElement(activeElement, event) {\n  const elementState = getElementState(activeElement);\n\n  // Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview/#keyboard-interaction-24\n  switch (`${elementState} ${event.key}`) {\n    case 'open ArrowRight':\n      // Focus first child node\n      return getFirstChildElement(activeElement);\n    case 'open ArrowLeft':\n      // Close node; don't change focus\n      return;\n    case 'closed ArrowRight':\n      // Open node; don't change focus\n      return;\n    case 'closed ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n    case 'end ArrowRight':\n      // Do nothing\n      return;\n    case 'end ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n  }\n\n  // ArrowUp, ArrowDown, Home, and End behavior are the same regarless of element state\n  switch (event.key) {\n    case 'ArrowUp':\n      // Focus previous visible element\n      return getVisibleElement(activeElement, 'previous');\n    case 'ArrowDown':\n      // Focus next visible element\n      return getVisibleElement(activeElement, 'next');\n    case 'Backspace':\n      return getParentElement(activeElement);\n    case 'Home':\n      // Focus first visible element\n      return getFirstElement(activeElement);\n    case 'End':\n      // Focus last visible element\n      return getLastElement(activeElement);\n    case 'PageUp':\n      return getPreviousPageElement(activeElement);\n    case 'PageDown':\n      return getNextPageElement(activeElement);\n  }\n}\nfunction getElementState(element) {\n  if (element.getAttribute('role') !== 'treeitem') {\n    throw new Error('Element is not a treeitem');\n  }\n  switch (element.getAttribute('aria-expanded')) {\n    case 'true':\n      return 'open';\n    case 'false':\n      return 'closed';\n    default:\n      return 'end';\n  }\n}\nfunction getVisibleElement(element, direction) {\n  const root = element.closest('[role=tree]');\n  if (!root) return;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, node => {\n    if (!(node instanceof HTMLElement)) return NodeFilter.FILTER_SKIP;\n    return node.getAttribute('role') === 'treeitem' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n  });\n  let current = walker.firstChild();\n  while (current !== element) {\n    current = walker.nextNode();\n  }\n  let next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n\n  // If next element is nested inside a collapsed subtree, continue iterating\n  while (next instanceof HTMLElement && (_next$parentElement = next.parentElement) !== null && _next$parentElement !== void 0 && _next$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _next$parentElement;\n    next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n  }\n  return next instanceof HTMLElement ? next : undefined;\n}\nfunction getFirstChildElement(element) {\n  const firstChild = element.querySelector('[role=treeitem]');\n  return firstChild instanceof HTMLElement ? firstChild : undefined;\n}\nfunction getParentElement(element) {\n  const group = element.closest('[role=group]');\n  const parent = group === null || group === void 0 ? void 0 : group.closest('[role=treeitem]');\n  return parent instanceof HTMLElement ? parent : undefined;\n}\nfunction getFirstElement(element) {\n  const root = element.closest('[role=tree]');\n  const first = root === null || root === void 0 ? void 0 : root.querySelector('[role=treeitem]');\n  return first instanceof HTMLElement ? first : undefined;\n}\nfunction getLastElement(element) {\n  const root = element.closest('[role=tree]');\n  const items = Array.from((root === null || root === void 0 ? void 0 : root.querySelectorAll('[role=treeitem]')) || []);\n\n  // If there are no items, return undefined\n  if (items.length === 0) return;\n  let index = items.length - 1;\n  let last = items[index];\n\n  // If last element is nested inside a collapsed subtree, continue iterating\n  while (index > 0 && last instanceof HTMLElement && (_last$parentElement = last.parentElement) !== null && _last$parentElement !== void 0 && _last$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _last$parentElement;\n    index -= 1;\n    last = items[index];\n  }\n  return last instanceof HTMLElement ? last : undefined;\n}\nconst defaultSize = {\n  height: 32\n};\n\n/**\n * Determine the page size for the given tree based on an item in the tree. We\n * estimate this size by trying to see how many items will fit in the given\n * tree. If the tree is within a scroll container, we will use the height of\n * that container. Otherwise, we'll use the current window height\n */\nfunction getPageSize(root, item) {\n  var _item$getBoundingClie, _scrollContainer$clie;\n  const scrollContainer = getScrollContainer(root);\n  const {\n    height: itemHeight\n  } = (_item$getBoundingClie = item === null || item === void 0 ? void 0 : item.getBoundingClientRect()) !== null && _item$getBoundingClie !== void 0 ? _item$getBoundingClie : defaultSize;\n  const availableHeight = (_scrollContainer$clie = scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.clientHeight) !== null && _scrollContainer$clie !== void 0 ? _scrollContainer$clie : window.innerHeight;\n  return Math.floor(availableHeight / itemHeight);\n}\nfunction getNextPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.min(items.length - 1, (page + 1) * pageSize + offset)];\n}\nfunction getPreviousPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.max(0, (page - 1) * pageSize + offset)];\n}\nexport { getElementState, getFirstChildElement, getFirstElement, getLastElement, getNextFocusableElement, getParentElement, getVisibleElement, useRovingTabIndex };","map":{"version":3,"names":["useFocusZone","getScrollContainer","FocusKeys","useRovingTabIndex","_ref","containerRef","bindKeys","ArrowVertical","ArrowHorizontal","HomeAndEnd","Backspace","PageUpDown","preventScroll","getNextFocusable","direction","from","event","_getNextFocusableElem","HTMLElement","getNextFocusableElement","focusInStrategy","_containerRef$current","_containerRef$current2","_containerRef$current3","currentItem","current","querySelector","firstItem","document","activeElement","contains","undefined","elementState","getElementState","key","getFirstChildElement","getParentElement","getVisibleElement","getFirstElement","getLastElement","getPreviousPageElement","getNextPageElement","element","getAttribute","Error","root","closest","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","node","FILTER_SKIP","FILTER_ACCEPT","firstChild","nextNode","next","previousNode","_next$parentElement","parentElement","group","parent","first","items","Array","querySelectorAll","length","index","last","_last$parentElement","defaultSize","height","getPageSize","item","_item$getBoundingClie","_scrollContainer$clie","scrollContainer","itemHeight","getBoundingClientRect","availableHeight","clientHeight","window","innerHeight","Math","floor","itemLabel","firstElementChild","pageSize","page","indexOf","offset","min","max"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/TreeView/useRovingTabIndex.js"],"sourcesContent":["import { useFocusZone } from '../hooks/useFocusZone.js';\nimport { getScrollContainer } from '../utils/scroll.js';\nimport { FocusKeys } from '@primer/behaviors';\n\nfunction useRovingTabIndex({\n  containerRef\n}) {\n  // TODO: Initialize focus to the aria-current item if it exists\n  useFocusZone({\n    containerRef,\n    bindKeys: FocusKeys.ArrowVertical | FocusKeys.ArrowHorizontal | FocusKeys.HomeAndEnd | FocusKeys.Backspace | FocusKeys.PageUpDown,\n    preventScroll: true,\n    getNextFocusable: (direction, from, event) => {\n      var _getNextFocusableElem;\n      if (!(from instanceof HTMLElement)) return;\n      return (_getNextFocusableElem = getNextFocusableElement(from, event)) !== null && _getNextFocusableElem !== void 0 ? _getNextFocusableElem : from;\n    },\n    focusInStrategy: () => {\n      var _containerRef$current, _containerRef$current2, _containerRef$current3;\n      const currentItem = (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.querySelector('[aria-current]');\n      const firstItem = (_containerRef$current2 = containerRef.current) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.querySelector('[role=\"treeitem\"]');\n\n      // Focus the aria-current item if it exists\n      if (currentItem instanceof HTMLElement) {\n        return currentItem;\n      }\n\n      // Otherwise, focus the activeElement if it's a treeitem\n      if (document.activeElement instanceof HTMLElement && (_containerRef$current3 = containerRef.current) !== null && _containerRef$current3 !== void 0 && _containerRef$current3.contains(document.activeElement)) {\n        return document.activeElement;\n      }\n\n      // Otherwise, focus the first treeitem\n      return firstItem instanceof HTMLElement ? firstItem : undefined;\n    }\n  });\n}\n\n// DOM utilities used for focus management\n\nfunction getNextFocusableElement(activeElement, event) {\n  const elementState = getElementState(activeElement);\n\n  // Reference: https://www.w3.org/WAI/ARIA/apg/patterns/treeview/#keyboard-interaction-24\n  switch (`${elementState} ${event.key}`) {\n    case 'open ArrowRight':\n      // Focus first child node\n      return getFirstChildElement(activeElement);\n    case 'open ArrowLeft':\n      // Close node; don't change focus\n      return;\n    case 'closed ArrowRight':\n      // Open node; don't change focus\n      return;\n    case 'closed ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n    case 'end ArrowRight':\n      // Do nothing\n      return;\n    case 'end ArrowLeft':\n      // Focus parent element\n      return getParentElement(activeElement);\n  }\n\n  // ArrowUp, ArrowDown, Home, and End behavior are the same regarless of element state\n  switch (event.key) {\n    case 'ArrowUp':\n      // Focus previous visible element\n      return getVisibleElement(activeElement, 'previous');\n    case 'ArrowDown':\n      // Focus next visible element\n      return getVisibleElement(activeElement, 'next');\n    case 'Backspace':\n      return getParentElement(activeElement);\n    case 'Home':\n      // Focus first visible element\n      return getFirstElement(activeElement);\n    case 'End':\n      // Focus last visible element\n      return getLastElement(activeElement);\n    case 'PageUp':\n      return getPreviousPageElement(activeElement);\n    case 'PageDown':\n      return getNextPageElement(activeElement);\n  }\n}\nfunction getElementState(element) {\n  if (element.getAttribute('role') !== 'treeitem') {\n    throw new Error('Element is not a treeitem');\n  }\n  switch (element.getAttribute('aria-expanded')) {\n    case 'true':\n      return 'open';\n    case 'false':\n      return 'closed';\n    default:\n      return 'end';\n  }\n}\nfunction getVisibleElement(element, direction) {\n  const root = element.closest('[role=tree]');\n  if (!root) return;\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, node => {\n    if (!(node instanceof HTMLElement)) return NodeFilter.FILTER_SKIP;\n    return node.getAttribute('role') === 'treeitem' ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n  });\n  let current = walker.firstChild();\n  while (current !== element) {\n    current = walker.nextNode();\n  }\n  let next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n\n  // If next element is nested inside a collapsed subtree, continue iterating\n  while (next instanceof HTMLElement && (_next$parentElement = next.parentElement) !== null && _next$parentElement !== void 0 && _next$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _next$parentElement;\n    next = direction === 'next' ? walker.nextNode() : walker.previousNode();\n  }\n  return next instanceof HTMLElement ? next : undefined;\n}\nfunction getFirstChildElement(element) {\n  const firstChild = element.querySelector('[role=treeitem]');\n  return firstChild instanceof HTMLElement ? firstChild : undefined;\n}\nfunction getParentElement(element) {\n  const group = element.closest('[role=group]');\n  const parent = group === null || group === void 0 ? void 0 : group.closest('[role=treeitem]');\n  return parent instanceof HTMLElement ? parent : undefined;\n}\nfunction getFirstElement(element) {\n  const root = element.closest('[role=tree]');\n  const first = root === null || root === void 0 ? void 0 : root.querySelector('[role=treeitem]');\n  return first instanceof HTMLElement ? first : undefined;\n}\nfunction getLastElement(element) {\n  const root = element.closest('[role=tree]');\n  const items = Array.from((root === null || root === void 0 ? void 0 : root.querySelectorAll('[role=treeitem]')) || []);\n\n  // If there are no items, return undefined\n  if (items.length === 0) return;\n  let index = items.length - 1;\n  let last = items[index];\n\n  // If last element is nested inside a collapsed subtree, continue iterating\n  while (index > 0 && last instanceof HTMLElement && (_last$parentElement = last.parentElement) !== null && _last$parentElement !== void 0 && _last$parentElement.closest('[role=treeitem][aria-expanded=false]')) {\n    var _last$parentElement;\n    index -= 1;\n    last = items[index];\n  }\n  return last instanceof HTMLElement ? last : undefined;\n}\nconst defaultSize = {\n  height: 32\n};\n\n/**\n * Determine the page size for the given tree based on an item in the tree. We\n * estimate this size by trying to see how many items will fit in the given\n * tree. If the tree is within a scroll container, we will use the height of\n * that container. Otherwise, we'll use the current window height\n */\nfunction getPageSize(root, item) {\n  var _item$getBoundingClie, _scrollContainer$clie;\n  const scrollContainer = getScrollContainer(root);\n  const {\n    height: itemHeight\n  } = (_item$getBoundingClie = item === null || item === void 0 ? void 0 : item.getBoundingClientRect()) !== null && _item$getBoundingClie !== void 0 ? _item$getBoundingClie : defaultSize;\n  const availableHeight = (_scrollContainer$clie = scrollContainer === null || scrollContainer === void 0 ? void 0 : scrollContainer.clientHeight) !== null && _scrollContainer$clie !== void 0 ? _scrollContainer$clie : window.innerHeight;\n  return Math.floor(availableHeight / itemHeight);\n}\nfunction getNextPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.min(items.length - 1, (page + 1) * pageSize + offset)];\n}\nfunction getPreviousPageElement(element) {\n  const root = element.closest('[role=\"tree\"]');\n  if (!root) {\n    return;\n  }\n  const items = Array.from(root.querySelectorAll('[role=\"treeitem\"]'));\n  if (items.length === 0) {\n    return;\n  }\n  const itemLabel = items[0].firstElementChild;\n  const pageSize = getPageSize(root, itemLabel);\n  const page = Math.floor(items.indexOf(element) / pageSize);\n  const offset = items.indexOf(element) - pageSize * page;\n  return items[Math.max(0, (page - 1) * pageSize + offset)];\n}\n\nexport { getElementState, getFirstChildElement, getFirstElement, getLastElement, getNextFocusableElement, getParentElement, getVisibleElement, useRovingTabIndex };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}