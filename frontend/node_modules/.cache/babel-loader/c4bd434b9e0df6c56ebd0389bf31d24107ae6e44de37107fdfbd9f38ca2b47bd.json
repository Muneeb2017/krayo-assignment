{"ast":null,"code":"import { polyfill as eventListenerSignalPolyfill } from './polyfills/event-listener-signal.js';\nimport { isMacOS } from './utils/user-agent.js';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.js';\nimport { uniqueId } from './utils/unique-id.js';\neventListenerSignalPolyfill();\nexport var FocusKeys;\n(function (FocusKeys) {\n  FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n  FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n  FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n  FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n  FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n  FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n  FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n  FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n  FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n  FocusKeys[FocusKeys[\"Backspace\"] = 512] = \"Backspace\";\n  FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n  FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n  FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n  FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\nconst KEY_TO_BIT = {\n  ArrowLeft: FocusKeys.ArrowHorizontal,\n  ArrowDown: FocusKeys.ArrowVertical,\n  ArrowUp: FocusKeys.ArrowVertical,\n  ArrowRight: FocusKeys.ArrowHorizontal,\n  h: FocusKeys.HL,\n  j: FocusKeys.JK,\n  k: FocusKeys.JK,\n  l: FocusKeys.HL,\n  a: FocusKeys.AD,\n  s: FocusKeys.WS,\n  w: FocusKeys.WS,\n  d: FocusKeys.AD,\n  Tab: FocusKeys.Tab,\n  Home: FocusKeys.HomeAndEnd,\n  End: FocusKeys.HomeAndEnd,\n  PageUp: FocusKeys.PageUpDown,\n  PageDown: FocusKeys.PageUpDown,\n  Backspace: FocusKeys.Backspace\n};\nconst KEY_TO_DIRECTION = {\n  ArrowLeft: 'previous',\n  ArrowDown: 'next',\n  ArrowUp: 'previous',\n  ArrowRight: 'next',\n  h: 'previous',\n  j: 'next',\n  k: 'previous',\n  l: 'next',\n  a: 'previous',\n  s: 'next',\n  w: 'previous',\n  d: 'next',\n  Tab: 'next',\n  Home: 'start',\n  End: 'end',\n  PageUp: 'start',\n  PageDown: 'end',\n  Backspace: 'previous'\n};\nfunction getDirection(keyboardEvent) {\n  const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n  if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n    return 'previous';\n  }\n  const isMac = isMacOS();\n  if (isMac && keyboardEvent.metaKey || !isMac && keyboardEvent.ctrlKey) {\n    if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n      return 'start';\n    } else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n      return 'end';\n    }\n  }\n  return direction;\n}\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n  const key = keyboardEvent.key;\n  const keyLength = [...key].length;\n  const isTextInput = activeElement instanceof HTMLInputElement && activeElement.type === 'text' || activeElement instanceof HTMLTextAreaElement;\n  if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n    return true;\n  }\n  if (activeElement instanceof HTMLSelectElement) {\n    if (keyLength === 1) {\n      return true;\n    }\n    if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n      return true;\n    }\n    if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n      return true;\n    }\n  }\n  if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n    return true;\n  }\n  if (isTextInput) {\n    const textInput = activeElement;\n    const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n    const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n    if (key === 'ArrowLeft' && !cursorAtStart) {\n      return true;\n    }\n    if (key === 'ArrowRight' && !cursorAtEnd) {\n      return true;\n    }\n    if (textInput instanceof HTMLTextAreaElement) {\n      if (key === 'ArrowUp' && !cursorAtStart) {\n        return true;\n      }\n      if (key === 'ArrowDown' && !cursorAtEnd) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nexport const isActiveDescendantAttribute = 'data-is-active-descendant';\nexport const activeDescendantActivatedDirectly = 'activated-directly';\nexport const activeDescendantActivatedIndirectly = 'activated-indirectly';\nexport const hasActiveDescendantAttribute = 'data-has-active-descendant';\nexport function focusZone(container, settings) {\n  var _a, _b, _c, _d, _e;\n  const focusableElements = [];\n  const savedTabIndex = new WeakMap();\n  const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n  const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n  const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n  const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n  const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n  let currentFocusedElement;\n  const preventScroll = (_d = settings === null || settings === void 0 ? void 0 : settings.preventScroll) !== null && _d !== void 0 ? _d : false;\n  function getFirstFocusableElement() {\n    return focusableElements[0];\n  }\n  function isActiveDescendantInputFocused() {\n    return document.activeElement === activeDescendantControl;\n  }\n  function updateFocusedElement(to) {\n    let directlyActivated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const from = currentFocusedElement;\n    currentFocusedElement = to;\n    if (activeDescendantControl) {\n      if (to && isActiveDescendantInputFocused()) {\n        setActiveDescendant(from, to, directlyActivated);\n      } else {\n        clearActiveDescendant();\n      }\n      return;\n    }\n    if (from && from !== to && savedTabIndex.has(from)) {\n      from.setAttribute('tabindex', '-1');\n    }\n    to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n  }\n  function setActiveDescendant(from, to) {\n    let directlyActivated = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!to.id) {\n      to.setAttribute('id', uniqueId());\n    }\n    if (from && from !== to) {\n      from.removeAttribute(isActiveDescendantAttribute);\n    }\n    if (!activeDescendantControl || !directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id) {\n      return;\n    }\n    activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n    container.setAttribute(hasActiveDescendantAttribute, to.id);\n    to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n    activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n  }\n  function clearActiveDescendant() {\n    let previouslyActiveElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : currentFocusedElement;\n    if (focusInStrategy === 'first') {\n      currentFocusedElement = undefined;\n    }\n    activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n    container.removeAttribute(hasActiveDescendantAttribute);\n    previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n    activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n  }\n  function beginFocusManagement() {\n    for (var _len = arguments.length, elements = new Array(_len), _key = 0; _key < _len; _key++) {\n      elements[_key] = arguments[_key];\n    }\n    const filteredElements = elements.filter(e => {\n      var _a, _b;\n      return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true;\n    });\n    if (filteredElements.length === 0) {\n      return;\n    }\n    focusableElements.splice(findInsertionIndex(filteredElements), 0, ...filteredElements);\n    for (const element of filteredElements) {\n      if (!savedTabIndex.has(element)) {\n        savedTabIndex.set(element, element.getAttribute('tabindex'));\n      }\n      element.setAttribute('tabindex', '-1');\n    }\n    if (!currentFocusedElement) {\n      updateFocusedElement(getFirstFocusableElement());\n    }\n  }\n  function findInsertionIndex(elementsToInsert) {\n    const firstElementToInsert = elementsToInsert[0];\n    if (focusableElements.length === 0) return 0;\n    let iMin = 0;\n    let iMax = focusableElements.length - 1;\n    while (iMin <= iMax) {\n      const i = Math.floor((iMin + iMax) / 2);\n      const element = focusableElements[i];\n      if (followsInDocument(firstElementToInsert, element)) {\n        iMax = i - 1;\n      } else {\n        iMin = i + 1;\n      }\n    }\n    return iMin;\n  }\n  function followsInDocument(first, second) {\n    return (second.compareDocumentPosition(first) & Node.DOCUMENT_POSITION_PRECEDING) > 0;\n  }\n  function endFocusManagement() {\n    for (var _len2 = arguments.length, elements = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      elements[_key2] = arguments[_key2];\n    }\n    for (const element of elements) {\n      const focusableElementIndex = focusableElements.indexOf(element);\n      if (focusableElementIndex >= 0) {\n        focusableElements.splice(focusableElementIndex, 1);\n      }\n      const savedIndex = savedTabIndex.get(element);\n      if (savedIndex !== undefined) {\n        if (savedIndex === null) {\n          element.removeAttribute('tabindex');\n        } else {\n          element.setAttribute('tabindex', savedIndex);\n        }\n        savedTabIndex.delete(element);\n      }\n      if (element === currentFocusedElement) {\n        const nextElementToFocus = getFirstFocusableElement();\n        updateFocusedElement(nextElementToFocus);\n      }\n    }\n  }\n  beginFocusManagement(...iterateFocusableElements(container));\n  const initialElement = typeof focusInStrategy === 'function' ? focusInStrategy(document.body) : getFirstFocusableElement();\n  updateFocusedElement(initialElement);\n  const observer = new MutationObserver(mutations => {\n    for (const mutation of mutations) {\n      for (const removedNode of mutation.removedNodes) {\n        if (removedNode instanceof HTMLElement) {\n          endFocusManagement(...iterateFocusableElements(removedNode));\n        }\n      }\n    }\n    for (const mutation of mutations) {\n      for (const addedNode of mutation.addedNodes) {\n        if (addedNode instanceof HTMLElement) {\n          beginFocusManagement(...iterateFocusableElements(addedNode));\n        }\n      }\n    }\n  });\n  observer.observe(container, {\n    subtree: true,\n    childList: true\n  });\n  const controller = new AbortController();\n  const signal = (_e = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _e !== void 0 ? _e : controller.signal;\n  signal.addEventListener('abort', () => {\n    endFocusManagement(...focusableElements);\n  });\n  let elementIndexFocusedByClick = undefined;\n  container.addEventListener('mousedown', event => {\n    if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n      elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n    }\n  }, {\n    signal\n  });\n  if (activeDescendantControl) {\n    container.addEventListener('focusin', event => {\n      if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n        activeDescendantControl.focus({\n          preventScroll\n        });\n        updateFocusedElement(event.target);\n      }\n    });\n    container.addEventListener('mousemove', _ref => {\n      let {\n        target\n      } = _ref;\n      if (!(target instanceof Node)) {\n        return;\n      }\n      const focusableElement = focusableElements.find(element => element.contains(target));\n      if (focusableElement) {\n        updateFocusedElement(focusableElement);\n      }\n    }, {\n      signal,\n      capture: true\n    });\n    activeDescendantControl.addEventListener('focusin', () => {\n      if (!currentFocusedElement) {\n        updateFocusedElement(getFirstFocusableElement());\n      } else {\n        setActiveDescendant(undefined, currentFocusedElement);\n      }\n    });\n    activeDescendantControl.addEventListener('focusout', () => {\n      clearActiveDescendant();\n    });\n  } else {\n    container.addEventListener('focusin', event => {\n      if (event.target instanceof HTMLElement) {\n        if (elementIndexFocusedByClick !== undefined) {\n          if (elementIndexFocusedByClick >= 0) {\n            if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n              updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n            }\n          }\n          elementIndexFocusedByClick = undefined;\n        } else {\n          if (focusInStrategy === 'previous') {\n            updateFocusedElement(event.target);\n          } else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n            if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n              const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n              const targetElement = focusableElements[targetElementIndex];\n              targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus({\n                preventScroll\n              });\n              return;\n            } else {\n              updateFocusedElement(event.target);\n            }\n          } else if (typeof focusInStrategy === 'function') {\n            if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n              const elementToFocus = focusInStrategy(event.relatedTarget);\n              const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n              if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                elementToFocus.focus({\n                  preventScroll\n                });\n                return;\n              } else {\n                console.warn('Element requested is not a known focusable element.');\n              }\n            } else {\n              updateFocusedElement(event.target);\n            }\n          }\n        }\n      }\n      lastKeyboardFocusDirection = undefined;\n    }, {\n      signal\n    });\n  }\n  const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n  let lastKeyboardFocusDirection = undefined;\n  if (focusInStrategy === 'closest') {\n    document.addEventListener('keydown', event => {\n      if (event.key === 'Tab') {\n        lastKeyboardFocusDirection = getDirection(event);\n      }\n    }, {\n      signal,\n      capture: true\n    });\n  }\n  function getCurrentFocusedIndex() {\n    if (!currentFocusedElement) {\n      return 0;\n    }\n    const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n    const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n    return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n  }\n  keyboardEventRecipient.addEventListener('keydown', event => {\n    var _a;\n    if (event.key in KEY_TO_DIRECTION) {\n      const keyBit = KEY_TO_BIT[event.key];\n      if (!event.defaultPrevented && (keyBit & bindKeys) > 0 && !shouldIgnoreFocusHandling(event, document.activeElement)) {\n        const direction = getDirection(event);\n        let nextElementToFocus = undefined;\n        if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n          nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n        }\n        if (!nextElementToFocus) {\n          const lastFocusedIndex = getCurrentFocusedIndex();\n          let nextFocusedIndex = lastFocusedIndex;\n          if (direction === 'previous') {\n            nextFocusedIndex -= 1;\n          } else if (direction === 'start') {\n            nextFocusedIndex = 0;\n          } else if (direction === 'next') {\n            nextFocusedIndex += 1;\n          } else {\n            nextFocusedIndex = focusableElements.length - 1;\n          }\n          if (nextFocusedIndex < 0) {\n            if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n              nextFocusedIndex = focusableElements.length - 1;\n            } else {\n              nextFocusedIndex = 0;\n            }\n          }\n          if (nextFocusedIndex >= focusableElements.length) {\n            if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n              nextFocusedIndex = 0;\n            } else {\n              nextFocusedIndex = focusableElements.length - 1;\n            }\n          }\n          if (lastFocusedIndex !== nextFocusedIndex) {\n            nextElementToFocus = focusableElements[nextFocusedIndex];\n          }\n        }\n        if (activeDescendantControl) {\n          updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n        } else if (nextElementToFocus) {\n          lastKeyboardFocusDirection = direction;\n          nextElementToFocus.focus({\n            preventScroll\n          });\n        }\n        if (event.key !== 'Tab' || nextElementToFocus) {\n          event.preventDefault();\n        }\n      }\n    }\n  }, {\n    signal\n  });\n  return controller;\n}","map":{"version":3,"names":["polyfill","eventListenerSignalPolyfill","isMacOS","iterateFocusableElements","uniqueId","FocusKeys","KEY_TO_BIT","ArrowLeft","ArrowHorizontal","ArrowDown","ArrowVertical","ArrowUp","ArrowRight","h","HL","j","JK","k","l","a","AD","s","WS","w","d","Tab","Home","HomeAndEnd","End","PageUp","PageUpDown","PageDown","Backspace","KEY_TO_DIRECTION","getDirection","keyboardEvent","direction","key","shiftKey","isMac","metaKey","ctrlKey","shouldIgnoreFocusHandling","activeElement","keyLength","length","isTextInput","HTMLInputElement","type","HTMLTextAreaElement","HTMLSelectElement","altKey","textInput","cursorAtStart","selectionStart","selectionEnd","cursorAtEnd","value","isActiveDescendantAttribute","activeDescendantActivatedDirectly","activeDescendantActivatedIndirectly","hasActiveDescendantAttribute","focusZone","container","settings","_a","_b","_c","_d","_e","focusableElements","savedTabIndex","WeakMap","bindKeys","getNextFocusable","ArrowAll","focusOutBehavior","focusInStrategy","activeDescendantControl","activeDescendantCallback","onActiveDescendantChanged","currentFocusedElement","preventScroll","getFirstFocusableElement","isActiveDescendantInputFocused","document","updateFocusedElement","to","directlyActivated","arguments","undefined","from","setActiveDescendant","clearActiveDescendant","has","setAttribute","id","removeAttribute","getAttribute","previouslyActiveElement","beginFocusManagement","_len","elements","Array","_key","filteredElements","filter","e","focusableElementFilter","call","splice","findInsertionIndex","element","set","elementsToInsert","firstElementToInsert","iMin","iMax","i","Math","floor","followsInDocument","first","second","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","endFocusManagement","_len2","_key2","focusableElementIndex","indexOf","savedIndex","get","delete","nextElementToFocus","initialElement","body","observer","MutationObserver","mutations","mutation","removedNode","removedNodes","HTMLElement","addedNode","addedNodes","observe","subtree","childList","controller","AbortController","signal","abortSignal","addEventListener","elementIndexFocusedByClick","event","target","includes","focus","_ref","focusableElement","find","contains","capture","relatedTarget","Element","targetElementIndex","lastKeyboardFocusDirection","targetElement","elementToFocus","requestedFocusElementIndex","console","warn","keyboardEventRecipient","getCurrentFocusedIndex","focusedIndex","fallbackIndex","keyBit","defaultPrevented","lastFocusedIndex","nextFocusedIndex","preventDefault"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/behaviors/dist/esm/focus-zone.js"],"sourcesContent":["import { polyfill as eventListenerSignalPolyfill } from './polyfills/event-listener-signal.js';\nimport { isMacOS } from './utils/user-agent.js';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.js';\nimport { uniqueId } from './utils/unique-id.js';\neventListenerSignalPolyfill();\nexport var FocusKeys;\n(function (FocusKeys) {\n    FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n    FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n    FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n    FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n    FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n    FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n    FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n    FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n    FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n    FocusKeys[FocusKeys[\"Backspace\"] = 512] = \"Backspace\";\n    FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n    FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n    FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n    FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\nconst KEY_TO_BIT = {\n    ArrowLeft: FocusKeys.ArrowHorizontal,\n    ArrowDown: FocusKeys.ArrowVertical,\n    ArrowUp: FocusKeys.ArrowVertical,\n    ArrowRight: FocusKeys.ArrowHorizontal,\n    h: FocusKeys.HL,\n    j: FocusKeys.JK,\n    k: FocusKeys.JK,\n    l: FocusKeys.HL,\n    a: FocusKeys.AD,\n    s: FocusKeys.WS,\n    w: FocusKeys.WS,\n    d: FocusKeys.AD,\n    Tab: FocusKeys.Tab,\n    Home: FocusKeys.HomeAndEnd,\n    End: FocusKeys.HomeAndEnd,\n    PageUp: FocusKeys.PageUpDown,\n    PageDown: FocusKeys.PageUpDown,\n    Backspace: FocusKeys.Backspace\n};\nconst KEY_TO_DIRECTION = {\n    ArrowLeft: 'previous',\n    ArrowDown: 'next',\n    ArrowUp: 'previous',\n    ArrowRight: 'next',\n    h: 'previous',\n    j: 'next',\n    k: 'previous',\n    l: 'next',\n    a: 'previous',\n    s: 'next',\n    w: 'previous',\n    d: 'next',\n    Tab: 'next',\n    Home: 'start',\n    End: 'end',\n    PageUp: 'start',\n    PageDown: 'end',\n    Backspace: 'previous'\n};\nfunction getDirection(keyboardEvent) {\n    const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n    if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n        return 'previous';\n    }\n    const isMac = isMacOS();\n    if ((isMac && keyboardEvent.metaKey) || (!isMac && keyboardEvent.ctrlKey)) {\n        if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n            return 'start';\n        }\n        else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n            return 'end';\n        }\n    }\n    return direction;\n}\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n    const key = keyboardEvent.key;\n    const keyLength = [...key].length;\n    const isTextInput = (activeElement instanceof HTMLInputElement && activeElement.type === 'text') ||\n        activeElement instanceof HTMLTextAreaElement;\n    if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n        return true;\n    }\n    if (activeElement instanceof HTMLSelectElement) {\n        if (keyLength === 1) {\n            return true;\n        }\n        if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n            return true;\n        }\n        if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n            return true;\n        }\n    }\n    if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n        return true;\n    }\n    if (isTextInput) {\n        const textInput = activeElement;\n        const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n        const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n        if (key === 'ArrowLeft' && !cursorAtStart) {\n            return true;\n        }\n        if (key === 'ArrowRight' && !cursorAtEnd) {\n            return true;\n        }\n        if (textInput instanceof HTMLTextAreaElement) {\n            if (key === 'ArrowUp' && !cursorAtStart) {\n                return true;\n            }\n            if (key === 'ArrowDown' && !cursorAtEnd) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport const isActiveDescendantAttribute = 'data-is-active-descendant';\nexport const activeDescendantActivatedDirectly = 'activated-directly';\nexport const activeDescendantActivatedIndirectly = 'activated-indirectly';\nexport const hasActiveDescendantAttribute = 'data-has-active-descendant';\nexport function focusZone(container, settings) {\n    var _a, _b, _c, _d, _e;\n    const focusableElements = [];\n    const savedTabIndex = new WeakMap();\n    const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n    const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n    const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n    const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n    const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n    let currentFocusedElement;\n    const preventScroll = (_d = settings === null || settings === void 0 ? void 0 : settings.preventScroll) !== null && _d !== void 0 ? _d : false;\n    function getFirstFocusableElement() {\n        return focusableElements[0];\n    }\n    function isActiveDescendantInputFocused() {\n        return document.activeElement === activeDescendantControl;\n    }\n    function updateFocusedElement(to, directlyActivated = false) {\n        const from = currentFocusedElement;\n        currentFocusedElement = to;\n        if (activeDescendantControl) {\n            if (to && isActiveDescendantInputFocused()) {\n                setActiveDescendant(from, to, directlyActivated);\n            }\n            else {\n                clearActiveDescendant();\n            }\n            return;\n        }\n        if (from && from !== to && savedTabIndex.has(from)) {\n            from.setAttribute('tabindex', '-1');\n        }\n        to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n    }\n    function setActiveDescendant(from, to, directlyActivated = false) {\n        if (!to.id) {\n            to.setAttribute('id', uniqueId());\n        }\n        if (from && from !== to) {\n            from.removeAttribute(isActiveDescendantAttribute);\n        }\n        if (!activeDescendantControl ||\n            (!directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id)) {\n            return;\n        }\n        activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n        container.setAttribute(hasActiveDescendantAttribute, to.id);\n        to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n    }\n    function clearActiveDescendant(previouslyActiveElement = currentFocusedElement) {\n        if (focusInStrategy === 'first') {\n            currentFocusedElement = undefined;\n        }\n        activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n        container.removeAttribute(hasActiveDescendantAttribute);\n        previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n    }\n    function beginFocusManagement(...elements) {\n        const filteredElements = elements.filter(e => { var _a, _b; return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true; });\n        if (filteredElements.length === 0) {\n            return;\n        }\n        focusableElements.splice(findInsertionIndex(filteredElements), 0, ...filteredElements);\n        for (const element of filteredElements) {\n            if (!savedTabIndex.has(element)) {\n                savedTabIndex.set(element, element.getAttribute('tabindex'));\n            }\n            element.setAttribute('tabindex', '-1');\n        }\n        if (!currentFocusedElement) {\n            updateFocusedElement(getFirstFocusableElement());\n        }\n    }\n    function findInsertionIndex(elementsToInsert) {\n        const firstElementToInsert = elementsToInsert[0];\n        if (focusableElements.length === 0)\n            return 0;\n        let iMin = 0;\n        let iMax = focusableElements.length - 1;\n        while (iMin <= iMax) {\n            const i = Math.floor((iMin + iMax) / 2);\n            const element = focusableElements[i];\n            if (followsInDocument(firstElementToInsert, element)) {\n                iMax = i - 1;\n            }\n            else {\n                iMin = i + 1;\n            }\n        }\n        return iMin;\n    }\n    function followsInDocument(first, second) {\n        return (second.compareDocumentPosition(first) & Node.DOCUMENT_POSITION_PRECEDING) > 0;\n    }\n    function endFocusManagement(...elements) {\n        for (const element of elements) {\n            const focusableElementIndex = focusableElements.indexOf(element);\n            if (focusableElementIndex >= 0) {\n                focusableElements.splice(focusableElementIndex, 1);\n            }\n            const savedIndex = savedTabIndex.get(element);\n            if (savedIndex !== undefined) {\n                if (savedIndex === null) {\n                    element.removeAttribute('tabindex');\n                }\n                else {\n                    element.setAttribute('tabindex', savedIndex);\n                }\n                savedTabIndex.delete(element);\n            }\n            if (element === currentFocusedElement) {\n                const nextElementToFocus = getFirstFocusableElement();\n                updateFocusedElement(nextElementToFocus);\n            }\n        }\n    }\n    beginFocusManagement(...iterateFocusableElements(container));\n    const initialElement = typeof focusInStrategy === 'function' ? focusInStrategy(document.body) : getFirstFocusableElement();\n    updateFocusedElement(initialElement);\n    const observer = new MutationObserver(mutations => {\n        for (const mutation of mutations) {\n            for (const removedNode of mutation.removedNodes) {\n                if (removedNode instanceof HTMLElement) {\n                    endFocusManagement(...iterateFocusableElements(removedNode));\n                }\n            }\n        }\n        for (const mutation of mutations) {\n            for (const addedNode of mutation.addedNodes) {\n                if (addedNode instanceof HTMLElement) {\n                    beginFocusManagement(...iterateFocusableElements(addedNode));\n                }\n            }\n        }\n    });\n    observer.observe(container, {\n        subtree: true,\n        childList: true\n    });\n    const controller = new AbortController();\n    const signal = (_e = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _e !== void 0 ? _e : controller.signal;\n    signal.addEventListener('abort', () => {\n        endFocusManagement(...focusableElements);\n    });\n    let elementIndexFocusedByClick = undefined;\n    container.addEventListener('mousedown', event => {\n        if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n            elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n        }\n    }, { signal });\n    if (activeDescendantControl) {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n                activeDescendantControl.focus({ preventScroll });\n                updateFocusedElement(event.target);\n            }\n        });\n        container.addEventListener('mousemove', ({ target }) => {\n            if (!(target instanceof Node)) {\n                return;\n            }\n            const focusableElement = focusableElements.find(element => element.contains(target));\n            if (focusableElement) {\n                updateFocusedElement(focusableElement);\n            }\n        }, { signal, capture: true });\n        activeDescendantControl.addEventListener('focusin', () => {\n            if (!currentFocusedElement) {\n                updateFocusedElement(getFirstFocusableElement());\n            }\n            else {\n                setActiveDescendant(undefined, currentFocusedElement);\n            }\n        });\n        activeDescendantControl.addEventListener('focusout', () => {\n            clearActiveDescendant();\n        });\n    }\n    else {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement) {\n                if (elementIndexFocusedByClick !== undefined) {\n                    if (elementIndexFocusedByClick >= 0) {\n                        if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n                            updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n                        }\n                    }\n                    elementIndexFocusedByClick = undefined;\n                }\n                else {\n                    if (focusInStrategy === 'previous') {\n                        updateFocusedElement(event.target);\n                    }\n                    else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n                            const targetElement = focusableElements[targetElementIndex];\n                            targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus({ preventScroll });\n                            return;\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                    else if (typeof focusInStrategy === 'function') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const elementToFocus = focusInStrategy(event.relatedTarget);\n                            const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n                            if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                                elementToFocus.focus({ preventScroll });\n                                return;\n                            }\n                            else {\n                                console.warn('Element requested is not a known focusable element.');\n                            }\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                }\n            }\n            lastKeyboardFocusDirection = undefined;\n        }, { signal });\n    }\n    const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n    let lastKeyboardFocusDirection = undefined;\n    if (focusInStrategy === 'closest') {\n        document.addEventListener('keydown', event => {\n            if (event.key === 'Tab') {\n                lastKeyboardFocusDirection = getDirection(event);\n            }\n        }, { signal, capture: true });\n    }\n    function getCurrentFocusedIndex() {\n        if (!currentFocusedElement) {\n            return 0;\n        }\n        const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n        const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n        return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n    }\n    keyboardEventRecipient.addEventListener('keydown', event => {\n        var _a;\n        if (event.key in KEY_TO_DIRECTION) {\n            const keyBit = KEY_TO_BIT[event.key];\n            if (!event.defaultPrevented &&\n                (keyBit & bindKeys) > 0 &&\n                !shouldIgnoreFocusHandling(event, document.activeElement)) {\n                const direction = getDirection(event);\n                let nextElementToFocus = undefined;\n                if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n                    nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n                }\n                if (!nextElementToFocus) {\n                    const lastFocusedIndex = getCurrentFocusedIndex();\n                    let nextFocusedIndex = lastFocusedIndex;\n                    if (direction === 'previous') {\n                        nextFocusedIndex -= 1;\n                    }\n                    else if (direction === 'start') {\n                        nextFocusedIndex = 0;\n                    }\n                    else if (direction === 'next') {\n                        nextFocusedIndex += 1;\n                    }\n                    else {\n                        nextFocusedIndex = focusableElements.length - 1;\n                    }\n                    if (nextFocusedIndex < 0) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                        else {\n                            nextFocusedIndex = 0;\n                        }\n                    }\n                    if (nextFocusedIndex >= focusableElements.length) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = 0;\n                        }\n                        else {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                    }\n                    if (lastFocusedIndex !== nextFocusedIndex) {\n                        nextElementToFocus = focusableElements[nextFocusedIndex];\n                    }\n                }\n                if (activeDescendantControl) {\n                    updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n                }\n                else if (nextElementToFocus) {\n                    lastKeyboardFocusDirection = direction;\n                    nextElementToFocus.focus({ preventScroll });\n                }\n                if (event.key !== 'Tab' || nextElementToFocus) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, { signal });\n    return controller;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}