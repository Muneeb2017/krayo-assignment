{"ast":null,"code":"import { Children } from 'react';\nconst singleWordTriggerTerminators = new Set([' ', '\\n']);\nconst multiWordTriggerTerminators = new Set(['.', '\\n']);\nconst isWhitespace = char => /\\s/.test(char);\n\n/**\n * Calculate whether or not suggestions should be shown based on the given state of the\n * input. If they should be shown, returns the show event.\n */\nconst calculateSuggestionsQuery = (triggers, text, caretLocation) => {\n  // Build backwards from the caret location until the most recent trigger character or terminator\n  for (let i = caretLocation - 1, query = '', potentialTriggers = triggers; i >= 0 && potentialTriggers.length > 0; i--) {\n    const character = text[i];\n    if (singleWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter(t => t.multiWord);\n    if (multiWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter(t => !t.multiWord);\n    for (const trigger of potentialTriggers.filter(t => character === t.triggerChar)) {\n      // Trigger chars must always be preceded by whitespace or be the first character in the input,\n      // and even a multi-word query cannot start with whitespace\n      if ((i === 0 || isWhitespace(text[i - 1])) && !isWhitespace(query[0])) return {\n        trigger,\n        query\n      };\n      potentialTriggers = potentialTriggers.filter(t => t !== trigger);\n    }\n    query = character + query;\n  }\n  return null;\n};\nconst getSuggestionValue = suggestion => typeof suggestion === 'string' ? suggestion : suggestion.value;\nconst getSuggestionKey = suggestion => {\n  var _suggestion$key;\n  return typeof suggestion === 'string' ? suggestion : (_suggestion$key = suggestion.key) !== null && _suggestion$key !== void 0 ? _suggestion$key : suggestion.value;\n};\n\n/**\n * Attempts to assert that the child element is of a supported type. This can't be enforced\n * by the type system so it has to be done as a runtime check. This isn't foolproof - a\n * component that forwards a ref to a correct element but does not forward event handlers\n * will not work. But it's the best we can reasonably do.\n */\nfunction requireChildrenToBeInput(child, childRef) {\n  Children.only(child); // Assert that the child is lonely\n  if (\n  // There is no way to know what type the underlying child is until it mounts, so this\n  // will always pass on first render before failing on the second render\n  childRef.current && !(childRef.current instanceof HTMLInputElement) && !(childRef.current instanceof HTMLTextAreaElement)) {\n    throw new TypeError(`AutocompleteTextarea child must be a component that forwards a ref and props to an <input> or <textarea> element.`);\n  }\n  return child;\n}\n\n/**\n * Combine several event handlers into one. The last handler in the list is called first\n * and no further handlers will be called if `event.preventDefault()` is called.\n */\nconst augmentHandler = function () {\n  for (var _len = arguments.length, handlers = new Array(_len), _key = 0; _key < _len; _key++) {\n    handlers[_key] = arguments[_key];\n  }\n  return event => {\n    for (const handler of [...handlers].reverse()) {\n      if (!event.isDefaultPrevented()) handler === null || handler === void 0 ? void 0 : handler(event);\n    }\n  };\n};\nexport { augmentHandler, calculateSuggestionsQuery, getSuggestionKey, getSuggestionValue, requireChildrenToBeInput };","map":{"version":3,"names":["Children","singleWordTriggerTerminators","Set","multiWordTriggerTerminators","isWhitespace","char","test","calculateSuggestionsQuery","triggers","text","caretLocation","i","query","potentialTriggers","length","character","has","filter","t","multiWord","trigger","triggerChar","getSuggestionValue","suggestion","value","getSuggestionKey","_suggestion$key","key","requireChildrenToBeInput","child","childRef","only","current","HTMLInputElement","HTMLTextAreaElement","TypeError","augmentHandler","_len","arguments","handlers","Array","_key","event","handler","reverse","isDefaultPrevented"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/drafts/InlineAutocomplete/utils.js"],"sourcesContent":["import { Children } from 'react';\n\nconst singleWordTriggerTerminators = new Set([' ', '\\n']);\nconst multiWordTriggerTerminators = new Set(['.', '\\n']);\nconst isWhitespace = char => /\\s/.test(char);\n\n/**\n * Calculate whether or not suggestions should be shown based on the given state of the\n * input. If they should be shown, returns the show event.\n */\nconst calculateSuggestionsQuery = (triggers, text, caretLocation) => {\n  // Build backwards from the caret location until the most recent trigger character or terminator\n  for (let i = caretLocation - 1, query = '', potentialTriggers = triggers; i >= 0 && potentialTriggers.length > 0; i--) {\n    const character = text[i];\n    if (singleWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter(t => t.multiWord);\n    if (multiWordTriggerTerminators.has(character)) potentialTriggers = potentialTriggers.filter(t => !t.multiWord);\n    for (const trigger of potentialTriggers.filter(t => character === t.triggerChar)) {\n      // Trigger chars must always be preceded by whitespace or be the first character in the input,\n      // and even a multi-word query cannot start with whitespace\n      if ((i === 0 || isWhitespace(text[i - 1])) && !isWhitespace(query[0])) return {\n        trigger,\n        query\n      };\n      potentialTriggers = potentialTriggers.filter(t => t !== trigger);\n    }\n    query = character + query;\n  }\n  return null;\n};\nconst getSuggestionValue = suggestion => typeof suggestion === 'string' ? suggestion : suggestion.value;\nconst getSuggestionKey = suggestion => {\n  var _suggestion$key;\n  return typeof suggestion === 'string' ? suggestion : (_suggestion$key = suggestion.key) !== null && _suggestion$key !== void 0 ? _suggestion$key : suggestion.value;\n};\n\n/**\n * Attempts to assert that the child element is of a supported type. This can't be enforced\n * by the type system so it has to be done as a runtime check. This isn't foolproof - a\n * component that forwards a ref to a correct element but does not forward event handlers\n * will not work. But it's the best we can reasonably do.\n */\nfunction requireChildrenToBeInput(child, childRef) {\n  Children.only(child); // Assert that the child is lonely\n  if (\n  // There is no way to know what type the underlying child is until it mounts, so this\n  // will always pass on first render before failing on the second render\n  childRef.current && !(childRef.current instanceof HTMLInputElement) && !(childRef.current instanceof HTMLTextAreaElement)) {\n    throw new TypeError(`AutocompleteTextarea child must be a component that forwards a ref and props to an <input> or <textarea> element.`);\n  }\n  return child;\n}\n\n/**\n * Combine several event handlers into one. The last handler in the list is called first\n * and no further handlers will be called if `event.preventDefault()` is called.\n */\nconst augmentHandler = (...handlers) => event => {\n  for (const handler of [...handlers].reverse()) {\n    if (!event.isDefaultPrevented()) handler === null || handler === void 0 ? void 0 : handler(event);\n  }\n};\n\nexport { augmentHandler, calculateSuggestionsQuery, getSuggestionKey, getSuggestionValue, requireChildrenToBeInput };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}