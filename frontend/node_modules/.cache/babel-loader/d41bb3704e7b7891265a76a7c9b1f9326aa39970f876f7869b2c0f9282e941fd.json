{"ast":null,"code":"function buildPaginationModel(pageCount, currentPage, showPages, marginPageCount, surroundingPageCount) {\n  const pages = [];\n  if (showPages) {\n    const pageNums = [];\n    const addPage = n => {\n      if (n >= 1 && n <= pageCount) {\n        pageNums.push(n);\n      }\n    };\n\n    // Start by defining the window of pages to show around the current page.\n    // If the window goes off either edge, shift it until it fits.\n    let extentLeft = currentPage - surroundingPageCount;\n    let extentRight = currentPage + surroundingPageCount;\n    if (extentLeft < 1 && extentRight > pageCount) {\n      // Our window is larger than the entire range,\n      // so simply display every page.\n      extentLeft = 1;\n      extentRight = pageCount;\n    } else if (extentLeft < 1) {\n      while (extentLeft < 1) {\n        extentLeft++;\n        extentRight++;\n      }\n    } else if (extentRight > pageCount) {\n      while (extentRight > pageCount) {\n        extentLeft--;\n        extentRight--;\n      }\n    }\n\n    // Next, include the pages in the margins.\n    // If a margin page is already covered in the window,\n    // extend the window to the other direction.\n    for (let i = 1; i <= marginPageCount; i++) {\n      const leftPage = i;\n      const rightPage = pageCount - (i - 1);\n      if (leftPage >= extentLeft) {\n        extentRight++;\n      } else {\n        addPage(leftPage);\n      }\n      if (rightPage <= extentRight) {\n        extentLeft--;\n      } else {\n        addPage(rightPage);\n      }\n    }\n    for (let i = extentLeft; i <= extentRight; i++) {\n      addPage(i);\n    }\n    const sorted = pageNums.slice().sort((a, b) => a - b).filter((item, idx, ary) => !idx || item !== ary[idx - 1]);\n    for (let idx = 0; idx < sorted.length; idx++) {\n      const num = sorted[idx];\n      const selected = num === currentPage;\n      const last = sorted[idx - 1];\n      const next = sorted[idx + 1];\n      const lastDelta = num - last;\n      const nextDelta = num - next;\n      const precedesBreak = nextDelta !== -1;\n      if (idx === 0) {\n        if (num !== 1) {\n          // If the first page isn't page one,\n          // we need to add a break\n          pages.push({\n            type: 'BREAK',\n            num: 1\n          });\n        }\n        pages.push({\n          type: 'NUM',\n          num,\n          selected,\n          precedesBreak\n        });\n      } else {\n        if (lastDelta === 1) {\n          pages.push({\n            type: 'NUM',\n            num,\n            selected,\n            precedesBreak\n          });\n        } else {\n          // We skipped some, so add a break\n          pages.push({\n            type: 'BREAK',\n            num: num - 1\n          });\n          pages.push({\n            type: 'NUM',\n            num,\n            selected,\n            precedesBreak: false\n          });\n        }\n      }\n    }\n    const lastPage = pages[pages.length - 1];\n    if (lastPage.type === 'NUM' && lastPage.num !== pageCount) {\n      // The last page we rendered wasn't the actual last page,\n      // so we need an additional break\n      pages.push({\n        type: 'BREAK',\n        num: pageCount\n      });\n    }\n  }\n  const prev = {\n    type: 'PREV',\n    num: currentPage - 1,\n    disabled: currentPage === 1\n  };\n  const next = {\n    type: 'NEXT',\n    num: currentPage + 1,\n    disabled: currentPage === pageCount\n  };\n  return [prev, ...pages, next];\n}\nfunction buildComponentData(page, hrefBuilder, onClick) {\n  const props = {};\n  let content = '';\n  let key = '';\n  switch (page.type) {\n    case 'PREV':\n      {\n        key = 'page-prev';\n        content = 'Previous';\n        if (page.disabled) {\n          Object.assign(props, {\n            as: 'span',\n            'aria-disabled': 'true'\n          });\n        } else {\n          Object.assign(props, {\n            rel: 'prev',\n            href: hrefBuilder(page.num),\n            'aria-label': 'Previous Page',\n            onClick\n          });\n        }\n        break;\n      }\n    case 'NEXT':\n      {\n        key = 'page-next';\n        content = 'Next';\n        if (page.disabled) {\n          Object.assign(props, {\n            as: 'span',\n            'aria-disabled': 'true'\n          });\n        } else {\n          Object.assign(props, {\n            rel: 'next',\n            href: hrefBuilder(page.num),\n            'aria-label': 'Next Page',\n            onClick\n          });\n        }\n        break;\n      }\n    case 'NUM':\n      {\n        key = `page-${page.num}`;\n        content = String(page.num);\n        Object.assign(props, {\n          href: hrefBuilder(page.num),\n          // We append \"...\" to the aria-label for pages that preceed a break because screen readers will\n          // change the tone the text is read in.\n          // This is a slightly nicer experience than skipping a bunch of numbers unexpectedly.\n          'aria-label': `Page ${page.num}${page.precedesBreak ? '...' : ''}`,\n          onClick,\n          'aria-current': page.selected ? 'page' : undefined\n        });\n        break;\n      }\n    case 'BREAK':\n      {\n        key = `page-${page.num}-break`;\n        content = '…';\n        Object.assign(props, {\n          as: 'span',\n          role: 'presentation'\n        });\n      }\n  }\n  return {\n    props,\n    key,\n    content\n  };\n}\nexport { buildComponentData, buildPaginationModel };","map":{"version":3,"names":["buildPaginationModel","pageCount","currentPage","showPages","marginPageCount","surroundingPageCount","pages","pageNums","addPage","n","push","extentLeft","extentRight","i","leftPage","rightPage","sorted","slice","sort","a","b","filter","item","idx","ary","length","num","selected","last","next","lastDelta","nextDelta","precedesBreak","type","lastPage","prev","disabled","buildComponentData","page","hrefBuilder","onClick","props","content","key","Object","assign","as","rel","href","String","undefined","role"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/Pagination/model.js"],"sourcesContent":["function buildPaginationModel(pageCount, currentPage, showPages, marginPageCount, surroundingPageCount) {\n  const pages = [];\n  if (showPages) {\n    const pageNums = [];\n    const addPage = n => {\n      if (n >= 1 && n <= pageCount) {\n        pageNums.push(n);\n      }\n    };\n\n    // Start by defining the window of pages to show around the current page.\n    // If the window goes off either edge, shift it until it fits.\n    let extentLeft = currentPage - surroundingPageCount;\n    let extentRight = currentPage + surroundingPageCount;\n    if (extentLeft < 1 && extentRight > pageCount) {\n      // Our window is larger than the entire range,\n      // so simply display every page.\n      extentLeft = 1;\n      extentRight = pageCount;\n    } else if (extentLeft < 1) {\n      while (extentLeft < 1) {\n        extentLeft++;\n        extentRight++;\n      }\n    } else if (extentRight > pageCount) {\n      while (extentRight > pageCount) {\n        extentLeft--;\n        extentRight--;\n      }\n    }\n\n    // Next, include the pages in the margins.\n    // If a margin page is already covered in the window,\n    // extend the window to the other direction.\n    for (let i = 1; i <= marginPageCount; i++) {\n      const leftPage = i;\n      const rightPage = pageCount - (i - 1);\n      if (leftPage >= extentLeft) {\n        extentRight++;\n      } else {\n        addPage(leftPage);\n      }\n      if (rightPage <= extentRight) {\n        extentLeft--;\n      } else {\n        addPage(rightPage);\n      }\n    }\n    for (let i = extentLeft; i <= extentRight; i++) {\n      addPage(i);\n    }\n    const sorted = pageNums.slice().sort((a, b) => a - b).filter((item, idx, ary) => !idx || item !== ary[idx - 1]);\n    for (let idx = 0; idx < sorted.length; idx++) {\n      const num = sorted[idx];\n      const selected = num === currentPage;\n      const last = sorted[idx - 1];\n      const next = sorted[idx + 1];\n      const lastDelta = num - last;\n      const nextDelta = num - next;\n      const precedesBreak = nextDelta !== -1;\n      if (idx === 0) {\n        if (num !== 1) {\n          // If the first page isn't page one,\n          // we need to add a break\n          pages.push({\n            type: 'BREAK',\n            num: 1\n          });\n        }\n        pages.push({\n          type: 'NUM',\n          num,\n          selected,\n          precedesBreak\n        });\n      } else {\n        if (lastDelta === 1) {\n          pages.push({\n            type: 'NUM',\n            num,\n            selected,\n            precedesBreak\n          });\n        } else {\n          // We skipped some, so add a break\n          pages.push({\n            type: 'BREAK',\n            num: num - 1\n          });\n          pages.push({\n            type: 'NUM',\n            num,\n            selected,\n            precedesBreak: false\n          });\n        }\n      }\n    }\n    const lastPage = pages[pages.length - 1];\n    if (lastPage.type === 'NUM' && lastPage.num !== pageCount) {\n      // The last page we rendered wasn't the actual last page,\n      // so we need an additional break\n      pages.push({\n        type: 'BREAK',\n        num: pageCount\n      });\n    }\n  }\n  const prev = {\n    type: 'PREV',\n    num: currentPage - 1,\n    disabled: currentPage === 1\n  };\n  const next = {\n    type: 'NEXT',\n    num: currentPage + 1,\n    disabled: currentPage === pageCount\n  };\n  return [prev, ...pages, next];\n}\nfunction buildComponentData(page, hrefBuilder, onClick) {\n  const props = {};\n  let content = '';\n  let key = '';\n  switch (page.type) {\n    case 'PREV':\n      {\n        key = 'page-prev';\n        content = 'Previous';\n        if (page.disabled) {\n          Object.assign(props, {\n            as: 'span',\n            'aria-disabled': 'true'\n          });\n        } else {\n          Object.assign(props, {\n            rel: 'prev',\n            href: hrefBuilder(page.num),\n            'aria-label': 'Previous Page',\n            onClick\n          });\n        }\n        break;\n      }\n    case 'NEXT':\n      {\n        key = 'page-next';\n        content = 'Next';\n        if (page.disabled) {\n          Object.assign(props, {\n            as: 'span',\n            'aria-disabled': 'true'\n          });\n        } else {\n          Object.assign(props, {\n            rel: 'next',\n            href: hrefBuilder(page.num),\n            'aria-label': 'Next Page',\n            onClick\n          });\n        }\n        break;\n      }\n    case 'NUM':\n      {\n        key = `page-${page.num}`;\n        content = String(page.num);\n        Object.assign(props, {\n          href: hrefBuilder(page.num),\n          // We append \"...\" to the aria-label for pages that preceed a break because screen readers will\n          // change the tone the text is read in.\n          // This is a slightly nicer experience than skipping a bunch of numbers unexpectedly.\n          'aria-label': `Page ${page.num}${page.precedesBreak ? '...' : ''}`,\n          onClick,\n          'aria-current': page.selected ? 'page' : undefined\n        });\n        break;\n      }\n    case 'BREAK':\n      {\n        key = `page-${page.num}-break`;\n        content = '…';\n        Object.assign(props, {\n          as: 'span',\n          role: 'presentation'\n        });\n      }\n  }\n  return {\n    props,\n    key,\n    content\n  };\n}\n\nexport { buildComponentData, buildPaginationModel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}