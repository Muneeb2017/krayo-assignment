{"ast":null,"code":"// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst propertiesToCopy = ['direction',\n// RTL support\n'boxSizing', 'width',\n// on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n'height', 'overflowX', 'overflowY',\n// copy the scrollbar for IE\n\n'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderStyle', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font\n'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'fontSizeAdjust', 'lineHeight', 'fontFamily', 'textAlign', 'textTransform', 'textIndent', 'textDecoration',\n// might not make a difference, but better be safe\n\n'letterSpacing', 'wordSpacing', 'tabSize', 'MozTabSize' // prefixed version for Firefox <= 52\n];\n\n/**\n * Obtain the coordinates (px) of the bottom left of a character in an input, relative to the\n * top-left corner of the interior of the input (not adjusted for scroll).\n *\n * Adapted from https://github.com/koddsson/textarea-caret-position, which was itself\n * forked from https://github.com/component/textarea-caret-position.\n *\n * @param element The target input element.\n * @param index The index of the character to calculate.\n */\nfunction getCharacterCoordinates(element, index) {\n  const isFirefox = ('mozInnerScreenX' in window);\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n  const style = div.style;\n  const computed = window.getComputedStyle(element);\n\n  // Lineheight is either a number or the string 'normal'. In that case, fall back to a\n  // rough guess of 1.2 based on MDN: \"Desktop browsers use a default value of roughly 1.2\".\n  const lineHeight = isNaN(parseInt(computed.lineHeight)) ? parseInt(computed.fontSize) * 1.2 : parseInt(computed.lineHeight);\n  const isInput = element instanceof HTMLInputElement;\n\n  // Default wrapping styles\n  style.whiteSpace = isInput ? 'nowrap' : 'pre-wrap';\n  style.wordWrap = isInput ? '' : 'break-word';\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n\n  // Transfer the element's properties to the div\n  for (const prop of propertiesToCopy) {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height);\n        const outerHeight = parseInt(computed.paddingTop) + parseInt(computed.paddingBottom) + parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth);\n        const targetHeight = outerHeight + lineHeight;\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = '0';\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else if (!isInput && prop === 'width' && computed.boxSizing === 'border-box') {\n      // With box-sizing: border-box we need to offset the size slightly inwards.  This small difference can compound\n      // greatly in long textareas with lots of wrapping, leading to very innacurate results if not accounted for.\n      // Firefox will return computed styles in floats, like `0.9px`, while chromium might return `1px` for the same element.\n      // Either way we use `parseFloat` to turn `0.9px` into `0.9` and `1px` into `1`\n      const totalBorderWidth = parseFloat(computed.borderLeftWidth) + parseFloat(computed.borderRightWidth);\n      // When a vertical scrollbar is present it shrinks the content. We need to account for this by using clientWidth\n      // instead of width in everything but Firefox. When we do that we also have to account for the border width.\n      const width = isFirefox ? parseFloat(computed.width) - totalBorderWidth : element.clientWidth + totalBorderWidth;\n      style.width = `${width}px`;\n    } else {\n      style[prop] = computed[prop];\n    }\n  }\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height)) style.overflowY = 'scroll';\n  } else {\n    style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, index);\n\n  // The second special handling for input type=\"text\" vs textarea:\n  // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n  if (isInput) div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n  const span = document.createElement('span');\n  // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // For inputs, '.' is enough because there is no wrapping.\n  span.textContent = isInput ? '.' : element.value.substring(index) || '.'; // because a completely empty faux span doesn't render at all\n  div.appendChild(span);\n  const coordinates = {\n    top: span.offsetTop + parseInt(computed.borderTopWidth),\n    left: span.offsetLeft + parseInt(computed.borderLeftWidth),\n    height: lineHeight\n  };\n  document.body.removeChild(div);\n  return coordinates;\n}\n\n/**\n * Obtain the coordinates (px) of the bottom left of a character in an input, relative to the\n * top-left corner of the input element (adjusted for scroll). This includes horizontal\n * scroll in single-line inputs.\n * @param input The target input element.\n * @param index The index of the character to calculate for.\n */\nconst getScrollAdjustedCharacterCoordinates = (input, index) => {\n  const {\n    height,\n    top,\n    left\n  } = getCharacterCoordinates(input, index);\n  return {\n    height,\n    top: top - input.scrollTop,\n    left: left - input.scrollLeft\n  };\n};\n\n/**\n * Obtain the coordinates (px) of the bottom left of a character in an input, relative to the\n * top-left corner of the document. Since this is relative to the document, it is also adjusted\n * for the input's scroll.\n * @param input The target input element.\n * @param index The index of the character to calculate for.\n */\nconst getAbsoluteCharacterCoordinates = (input, index) => {\n  const {\n    top: relativeTop,\n    left: relativeLeft,\n    height\n  } = getScrollAdjustedCharacterCoordinates(input, index);\n  const {\n    top: viewportOffsetTop,\n    left: viewportOffsetLeft\n  } = input.getBoundingClientRect();\n  return {\n    height,\n    top: viewportOffsetTop + relativeTop,\n    left: viewportOffsetLeft + relativeLeft\n  };\n};\nexport { getAbsoluteCharacterCoordinates, getCharacterCoordinates, getScrollAdjustedCharacterCoordinates };","map":{"version":3,"names":["propertiesToCopy","getCharacterCoordinates","element","index","isFirefox","window","div","document","createElement","id","body","appendChild","style","computed","getComputedStyle","lineHeight","isNaN","parseInt","fontSize","isInput","HTMLInputElement","whiteSpace","wordWrap","position","prop","boxSizing","height","outerHeight","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","targetHeight","totalBorderWidth","parseFloat","borderLeftWidth","borderRightWidth","width","clientWidth","scrollHeight","overflowY","overflow","textContent","value","substring","replace","span","coordinates","top","offsetTop","left","offsetLeft","removeChild","getScrollAdjustedCharacterCoordinates","input","scrollTop","scrollLeft","getAbsoluteCharacterCoordinates","relativeTop","relativeLeft","viewportOffsetTop","viewportOffsetLeft","getBoundingClientRect"],"sources":["/home/muneeb/assignment-krayo/frontend/node_modules/@primer/react/lib-esm/drafts/utils/character-coordinates.js"],"sourcesContent":["// Note that some browsers, such as Firefox, do not concatenate properties\n// into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),\n// so we have to list every single property explicitly.\nconst propertiesToCopy = ['direction',\n// RTL support\n'boxSizing', 'width',\n// on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does\n'height', 'overflowX', 'overflowY',\n// copy the scrollbar for IE\n\n'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'borderStyle', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft',\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font\n'fontStyle', 'fontVariant', 'fontWeight', 'fontStretch', 'fontSize', 'fontSizeAdjust', 'lineHeight', 'fontFamily', 'textAlign', 'textTransform', 'textIndent', 'textDecoration',\n// might not make a difference, but better be safe\n\n'letterSpacing', 'wordSpacing', 'tabSize', 'MozTabSize' // prefixed version for Firefox <= 52\n];\n\n/**\n * Obtain the coordinates (px) of the bottom left of a character in an input, relative to the\n * top-left corner of the interior of the input (not adjusted for scroll).\n *\n * Adapted from https://github.com/koddsson/textarea-caret-position, which was itself\n * forked from https://github.com/component/textarea-caret-position.\n *\n * @param element The target input element.\n * @param index The index of the character to calculate.\n */\nfunction getCharacterCoordinates(element, index) {\n  const isFirefox = ('mozInnerScreenX' in window);\n\n  // The mirror div will replicate the textarea's style\n  const div = document.createElement('div');\n  div.id = 'input-textarea-caret-position-mirror-div';\n  document.body.appendChild(div);\n  const style = div.style;\n  const computed = window.getComputedStyle(element);\n\n  // Lineheight is either a number or the string 'normal'. In that case, fall back to a\n  // rough guess of 1.2 based on MDN: \"Desktop browsers use a default value of roughly 1.2\".\n  const lineHeight = isNaN(parseInt(computed.lineHeight)) ? parseInt(computed.fontSize) * 1.2 : parseInt(computed.lineHeight);\n  const isInput = element instanceof HTMLInputElement;\n\n  // Default wrapping styles\n  style.whiteSpace = isInput ? 'nowrap' : 'pre-wrap';\n  style.wordWrap = isInput ? '' : 'break-word';\n\n  // Position off-screen\n  style.position = 'absolute'; // required to return coordinates properly\n\n  // Transfer the element's properties to the div\n  for (const prop of propertiesToCopy) {\n    if (isInput && prop === 'lineHeight') {\n      // Special case for <input>s because text is rendered centered and line height may be != height\n      if (computed.boxSizing === 'border-box') {\n        const height = parseInt(computed.height);\n        const outerHeight = parseInt(computed.paddingTop) + parseInt(computed.paddingBottom) + parseInt(computed.borderTopWidth) + parseInt(computed.borderBottomWidth);\n        const targetHeight = outerHeight + lineHeight;\n        if (height > targetHeight) {\n          style.lineHeight = `${height - outerHeight}px`;\n        } else if (height === targetHeight) {\n          style.lineHeight = computed.lineHeight;\n        } else {\n          style.lineHeight = '0';\n        }\n      } else {\n        style.lineHeight = computed.height;\n      }\n    } else if (!isInput && prop === 'width' && computed.boxSizing === 'border-box') {\n      // With box-sizing: border-box we need to offset the size slightly inwards.  This small difference can compound\n      // greatly in long textareas with lots of wrapping, leading to very innacurate results if not accounted for.\n      // Firefox will return computed styles in floats, like `0.9px`, while chromium might return `1px` for the same element.\n      // Either way we use `parseFloat` to turn `0.9px` into `0.9` and `1px` into `1`\n      const totalBorderWidth = parseFloat(computed.borderLeftWidth) + parseFloat(computed.borderRightWidth);\n      // When a vertical scrollbar is present it shrinks the content. We need to account for this by using clientWidth\n      // instead of width in everything but Firefox. When we do that we also have to account for the border width.\n      const width = isFirefox ? parseFloat(computed.width) - totalBorderWidth : element.clientWidth + totalBorderWidth;\n      style.width = `${width}px`;\n    } else {\n      style[prop] = computed[prop];\n    }\n  }\n  if (isFirefox) {\n    // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275\n    if (element.scrollHeight > parseInt(computed.height)) style.overflowY = 'scroll';\n  } else {\n    style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'\n  }\n\n  div.textContent = element.value.substring(0, index);\n\n  // The second special handling for input type=\"text\" vs textarea:\n  // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037\n  if (isInput) div.textContent = div.textContent.replace(/\\s/g, '\\u00a0');\n  const span = document.createElement('span');\n  // Wrapping must be replicated *exactly*, including when a long word gets\n  // onto the next line, with whitespace at the end of the line before (#7).\n  // The  *only* reliable way to do that is to copy the *entire* rest of the\n  // textarea's content into the <span> created at the caret position.\n  // For inputs, '.' is enough because there is no wrapping.\n  span.textContent = isInput ? '.' : element.value.substring(index) || '.'; // because a completely empty faux span doesn't render at all\n  div.appendChild(span);\n  const coordinates = {\n    top: span.offsetTop + parseInt(computed.borderTopWidth),\n    left: span.offsetLeft + parseInt(computed.borderLeftWidth),\n    height: lineHeight\n  };\n  document.body.removeChild(div);\n  return coordinates;\n}\n\n/**\n * Obtain the coordinates (px) of the bottom left of a character in an input, relative to the\n * top-left corner of the input element (adjusted for scroll). This includes horizontal\n * scroll in single-line inputs.\n * @param input The target input element.\n * @param index The index of the character to calculate for.\n */\nconst getScrollAdjustedCharacterCoordinates = (input, index) => {\n  const {\n    height,\n    top,\n    left\n  } = getCharacterCoordinates(input, index);\n  return {\n    height,\n    top: top - input.scrollTop,\n    left: left - input.scrollLeft\n  };\n};\n\n/**\n * Obtain the coordinates (px) of the bottom left of a character in an input, relative to the\n * top-left corner of the document. Since this is relative to the document, it is also adjusted\n * for the input's scroll.\n * @param input The target input element.\n * @param index The index of the character to calculate for.\n */\nconst getAbsoluteCharacterCoordinates = (input, index) => {\n  const {\n    top: relativeTop,\n    left: relativeLeft,\n    height\n  } = getScrollAdjustedCharacterCoordinates(input, index);\n  const {\n    top: viewportOffsetTop,\n    left: viewportOffsetLeft\n  } = input.getBoundingClientRect();\n  return {\n    height,\n    top: viewportOffsetTop + relativeTop,\n    left: viewportOffsetLeft + relativeLeft\n  };\n};\n\nexport { getAbsoluteCharacterCoordinates, getCharacterCoordinates, getScrollAdjustedCharacterCoordinates };\n"],"mappings":"AAAA;AACA;AACA;AACA,MAAMA,gBAAgB,GAAG,CAAC,WAAW;AACrC;AACA,WAAW,EAAE,OAAO;AACpB;AACA,QAAQ,EAAE,WAAW,EAAE,WAAW;AAClC;;AAEA,gBAAgB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,iBAAiB,EAAE,aAAa,EAAE,YAAY,EAAE,cAAc,EAAE,eAAe,EAAE,aAAa;AACzJ;AACA,WAAW,EAAE,aAAa,EAAE,YAAY,EAAE,aAAa,EAAE,UAAU,EAAE,gBAAgB,EAAE,YAAY,EAAE,YAAY,EAAE,WAAW,EAAE,eAAe,EAAE,YAAY,EAAE,gBAAgB;AAC/K;;AAEA,eAAe,EAAE,aAAa,EAAE,SAAS,EAAE,YAAY,CAAC;AAAA,CACvD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,uBAAuBA,CAACC,OAAO,EAAEC,KAAK,EAAE;EAC/C,MAAMC,SAAS,IAAI,iBAAiB,IAAIC,MAAM,CAAC;;EAE/C;EACA,MAAMC,GAAG,GAAGC,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;EACzCF,GAAG,CAACG,EAAE,GAAG,0CAA0C;EACnDF,QAAQ,CAACG,IAAI,CAACC,WAAW,CAACL,GAAG,CAAC;EAC9B,MAAMM,KAAK,GAAGN,GAAG,CAACM,KAAK;EACvB,MAAMC,QAAQ,GAAGR,MAAM,CAACS,gBAAgB,CAACZ,OAAO,CAAC;;EAEjD;EACA;EACA,MAAMa,UAAU,GAAGC,KAAK,CAACC,QAAQ,CAACJ,QAAQ,CAACE,UAAU,CAAC,CAAC,GAAGE,QAAQ,CAACJ,QAAQ,CAACK,QAAQ,CAAC,GAAG,GAAG,GAAGD,QAAQ,CAACJ,QAAQ,CAACE,UAAU,CAAC;EAC3H,MAAMI,OAAO,GAAGjB,OAAO,YAAYkB,gBAAgB;;EAEnD;EACAR,KAAK,CAACS,UAAU,GAAGF,OAAO,GAAG,QAAQ,GAAG,UAAU;EAClDP,KAAK,CAACU,QAAQ,GAAGH,OAAO,GAAG,EAAE,GAAG,YAAY;;EAE5C;EACAP,KAAK,CAACW,QAAQ,GAAG,UAAU,CAAC,CAAC;;EAE7B;EACA,KAAK,MAAMC,IAAI,IAAIxB,gBAAgB,EAAE;IACnC,IAAImB,OAAO,IAAIK,IAAI,KAAK,YAAY,EAAE;MACpC;MACA,IAAIX,QAAQ,CAACY,SAAS,KAAK,YAAY,EAAE;QACvC,MAAMC,MAAM,GAAGT,QAAQ,CAACJ,QAAQ,CAACa,MAAM,CAAC;QACxC,MAAMC,WAAW,GAAGV,QAAQ,CAACJ,QAAQ,CAACe,UAAU,CAAC,GAAGX,QAAQ,CAACJ,QAAQ,CAACgB,aAAa,CAAC,GAAGZ,QAAQ,CAACJ,QAAQ,CAACiB,cAAc,CAAC,GAAGb,QAAQ,CAACJ,QAAQ,CAACkB,iBAAiB,CAAC;QAC/J,MAAMC,YAAY,GAAGL,WAAW,GAAGZ,UAAU;QAC7C,IAAIW,MAAM,GAAGM,YAAY,EAAE;UACzBpB,KAAK,CAACG,UAAU,GAAI,GAAEW,MAAM,GAAGC,WAAY,IAAG;QAChD,CAAC,MAAM,IAAID,MAAM,KAAKM,YAAY,EAAE;UAClCpB,KAAK,CAACG,UAAU,GAAGF,QAAQ,CAACE,UAAU;QACxC,CAAC,MAAM;UACLH,KAAK,CAACG,UAAU,GAAG,GAAG;QACxB;MACF,CAAC,MAAM;QACLH,KAAK,CAACG,UAAU,GAAGF,QAAQ,CAACa,MAAM;MACpC;IACF,CAAC,MAAM,IAAI,CAACP,OAAO,IAAIK,IAAI,KAAK,OAAO,IAAIX,QAAQ,CAACY,SAAS,KAAK,YAAY,EAAE;MAC9E;MACA;MACA;MACA;MACA,MAAMQ,gBAAgB,GAAGC,UAAU,CAACrB,QAAQ,CAACsB,eAAe,CAAC,GAAGD,UAAU,CAACrB,QAAQ,CAACuB,gBAAgB,CAAC;MACrG;MACA;MACA,MAAMC,KAAK,GAAGjC,SAAS,GAAG8B,UAAU,CAACrB,QAAQ,CAACwB,KAAK,CAAC,GAAGJ,gBAAgB,GAAG/B,OAAO,CAACoC,WAAW,GAAGL,gBAAgB;MAChHrB,KAAK,CAACyB,KAAK,GAAI,GAAEA,KAAM,IAAG;IAC5B,CAAC,MAAM;MACLzB,KAAK,CAACY,IAAI,CAAC,GAAGX,QAAQ,CAACW,IAAI,CAAC;IAC9B;EACF;EACA,IAAIpB,SAAS,EAAE;IACb;IACA,IAAIF,OAAO,CAACqC,YAAY,GAAGtB,QAAQ,CAACJ,QAAQ,CAACa,MAAM,CAAC,EAAEd,KAAK,CAAC4B,SAAS,GAAG,QAAQ;EAClF,CAAC,MAAM;IACL5B,KAAK,CAAC6B,QAAQ,GAAG,QAAQ,CAAC,CAAC;EAC7B;;EAEAnC,GAAG,CAACoC,WAAW,GAAGxC,OAAO,CAACyC,KAAK,CAACC,SAAS,CAAC,CAAC,EAAEzC,KAAK,CAAC;;EAEnD;EACA;EACA,IAAIgB,OAAO,EAAEb,GAAG,CAACoC,WAAW,GAAGpC,GAAG,CAACoC,WAAW,CAACG,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC;EACvE,MAAMC,IAAI,GAAGvC,QAAQ,CAACC,aAAa,CAAC,MAAM,CAAC;EAC3C;EACA;EACA;EACA;EACA;EACAsC,IAAI,CAACJ,WAAW,GAAGvB,OAAO,GAAG,GAAG,GAAGjB,OAAO,CAACyC,KAAK,CAACC,SAAS,CAACzC,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC;EAC1EG,GAAG,CAACK,WAAW,CAACmC,IAAI,CAAC;EACrB,MAAMC,WAAW,GAAG;IAClBC,GAAG,EAAEF,IAAI,CAACG,SAAS,GAAGhC,QAAQ,CAACJ,QAAQ,CAACiB,cAAc,CAAC;IACvDoB,IAAI,EAAEJ,IAAI,CAACK,UAAU,GAAGlC,QAAQ,CAACJ,QAAQ,CAACsB,eAAe,CAAC;IAC1DT,MAAM,EAAEX;EACV,CAAC;EACDR,QAAQ,CAACG,IAAI,CAAC0C,WAAW,CAAC9C,GAAG,CAAC;EAC9B,OAAOyC,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMM,qCAAqC,GAAGA,CAACC,KAAK,EAAEnD,KAAK,KAAK;EAC9D,MAAM;IACJuB,MAAM;IACNsB,GAAG;IACHE;EACF,CAAC,GAAGjD,uBAAuB,CAACqD,KAAK,EAAEnD,KAAK,CAAC;EACzC,OAAO;IACLuB,MAAM;IACNsB,GAAG,EAAEA,GAAG,GAAGM,KAAK,CAACC,SAAS;IAC1BL,IAAI,EAAEA,IAAI,GAAGI,KAAK,CAACE;EACrB,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,+BAA+B,GAAGA,CAACH,KAAK,EAAEnD,KAAK,KAAK;EACxD,MAAM;IACJ6C,GAAG,EAAEU,WAAW;IAChBR,IAAI,EAAES,YAAY;IAClBjC;EACF,CAAC,GAAG2B,qCAAqC,CAACC,KAAK,EAAEnD,KAAK,CAAC;EACvD,MAAM;IACJ6C,GAAG,EAAEY,iBAAiB;IACtBV,IAAI,EAAEW;EACR,CAAC,GAAGP,KAAK,CAACQ,qBAAqB,EAAE;EACjC,OAAO;IACLpC,MAAM;IACNsB,GAAG,EAAEY,iBAAiB,GAAGF,WAAW;IACpCR,IAAI,EAAEW,kBAAkB,GAAGF;EAC7B,CAAC;AACH,CAAC;AAED,SAASF,+BAA+B,EAAExD,uBAAuB,EAAEoD,qCAAqC"},"metadata":{},"sourceType":"module","externalDependencies":[]}